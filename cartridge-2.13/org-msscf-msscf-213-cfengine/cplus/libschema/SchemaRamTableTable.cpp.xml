<?xml version="1.0" encoding="UTF-8"?>
<!--
 *	MSS Code Factory 2.13 Knowledge Base
 *
 *	Copyright (c) 2020 Mark Stephen Sobkow
 *
 *	MSS Code Factory 2.13 Knowledge Base is distributed under Mark Stephen
 *	Sobkow's Proprietary Data License, Version 1.0.
 *
 *	MSS Code Factory 2.13 Knowledge Base is proprietary code and is only available
 *	for production and distribution builds and environments for use in running the
 *	MSS Code Factory executables delivered.  Only registered .edu organizations may
 *	modify, extend, or refactor this knowledge base for research or courseware use.
 *
 *	The code produced by MSS Code Factory or an educational derivative thereof under
 *	an educational authorization may not be used to produced any software that is to
 *	be used for anything but research and couseware use.  You may not use an
 *	educational authorization to produce code for any business or publice use
 *	without a commercial license.
 *
 *	You may install one copy of MSS Code Factory 2.13 Knowledge Base per installation
 *	of MSS Code Factory.  You may not redistribute this data software in any form
 *	without a commercial or educational authorization license.
 *
 *	MSS Code Factory 2.13 Knowledge Base is published so that you may study it for
 *	academic purposes, perform security verification reviews, and run the MSS Code
 *	Factory tool itself.
 *
 *	Any use of a modified or extended version of MSS Code Factory 2.13 Knowledge
 *	Base in a production environment, or use of code produced by applying such
 *	a version without a commercial license from Mark Stephen Sobkow is strictly
 *	forbidden.
 *
 *	MSS Code Factory 2.13 Knowledge Base is distributed in the hope that it will
 *	be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	Donations to support MSS Code Factory 2.13 Knowledge Base can be made at
 *	https://www.paypal.com/paypalme2/MarkSobkow
 *
 *	Please contact Mark Stephen Sobkow at mark.sobkow@gmail.com for commercial licensing.
 * -->
<RuleSet
	xmlns="uri://org.msscf/msscf/2.0.13/cfgenkb-2.13-ruleset"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xsi:schemaLocation="uri://org.msscf/msscf/2.0.13/cfgenkb-2.13-ruleset file:/opt/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	ToolSet="cplus"
	Name="libschemaram/SchemaRamTableTable.cpp"
	Revision="2.13"
	Descr="C++18 Implementation of an in-memory RAM DbIO for Table">

	<GenFile GenDef="Table" Name="fileSchemaRamTableTableCPlus"
			GenerateOnce="false"
			ModuleName=""
		SourceBundle="cplus"
		BasePackageName="libcfcore"
		SubPackageName=""
		ExpansionClassName="$SchemaName$Ram$TableName$TableCPlus"
		ExpansionKeyName="$SchemaName$Ram$TableName$TableCPlus"
		ExpansionFileName="$SchemaName$Ram$TableName$Table.cpp">
// Description: C++18 Implementation for an in-memory RAM DbIO for $TableName$.

$MssSourceLicense$

#include &lt;cflib/ICFLibPublic.hpp&gt;
#include &lt;$lower SchemaName$/I$SchemaName$Public.hpp&gt;$poptop SchemaDef iterate SchemaTables( each includeSchemaRamTableHPlus )$

using namespace std;

namespace $CPlusNamespace$ {

	const std::string $SchemaName$Ram$TableName$Table::CLASS_NAME( "$SchemaName$Ram$TableName$Table" );
$implConstructRamTableTable$$moreRamTableMethods$$CPlusRamTableImplementation$
}
</GenFile>

	<GenRule GenDef="RelationCol" Name="IsToColNullable"
		>$reference ToCol IsNullable$</GenRule>

	<GenRule GenDef="Index" Name="PageData"
		>$poptop Table PageData$</GenRule>

	<GenRule GenDef="ServerProc" Name="implServerMethod"
		>$switch IsInstanceMethod yes implInstServerProc default implClassServerProc$</GenRule>

	<GenRule GenDef="ServerProc" Name="implClassServerProc">
	bool $poptop Table SchemaName$Ram$poptop Table TableName$Table::$leadlower Name$( $CPlusDefNamespace$::I$DefSchemaName$SchemaObj* schemaObj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$CPlusMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerProc" Name="implInstServerProc">
	bool $poptop Table SchemaName$Ram$poptop Table TableName$Table::$leadlower Name$( $CPlusDefNamespace$::I$DefSchemaName$SchemaObj* schemaObj,
		$CPlusDefNamespace$::I$DefSchemaName$$TableName$Obj* obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$CPlusMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implServerMethod"
		>$switch IsInstanceMethod yes implInstServerObjFunc default implClassServerObjFunc$</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implClassServerObjFunc">
	$reference RetTable CPlusDefNamespace$::$reference RetTable DefSchemaName$$reference RetTable Name$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::$leadlower Name$( $CPlusDefNamespace$::I$DefSchemaName$SchemaObj* schemaObj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$CPlusMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implInstServerObjFunc">
	$reference RetTable CPlusDefNamespace$::$reference RetTable DefSchemaName$$reference RetTable Name$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::$leadlower Name$( $CPlusDefNamespace$::I$DefSchemaName$SchemaObj* schemaObj,
		$CPlusDefNamespace$::I$DefSchemaName$$TableName$Obj* obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$CPlusMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implServerMethod"
		>$switch IsInstanceMethod yes implInstServerListFunc default implClassServerListFunc$</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implClassServerListFunc">
	std::TCFLibOwningVector&lt;$reference RetTable CPlusDefNamespace$::$reference RetTable DefSchemaName$$reference RetTable Name$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::$leadlower Name$( $CPlusDefNamespace$::I$DefSchemaName$SchemaObj* schemaObj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$CPlusMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implInstServerListFunc">
	std::TCFLibOwningVector&lt;$reference RetTable CPlusDefNamespace$::$reference RetTable DefSchemaName$$reference RetTable Name$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::$leadlower Name$( $CPlusDefNamespace$::I$DefSchemaName$SchemaObj* schemaObj,
		$CPlusDefNamespace$::I$DefSchemaName$$TableName$Obj* obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$CPlusMethodBody$	}
</GenRule>

	<GenRule GenDef="Table" Name="moreRamTableMethods"
		>$iterate DispensedId16Generators( first implRamTableGenerateNextId16 each empty empty empty )$$iterate DispensedId32Generators( first implRamTableGenerateNextId32 each empty empty empty )$$iterate DispensedId64Generators( first implRamTableGenerateNextId64 each empty empty empty )$$iterate DispensedId16Generators( each implRamNextIdGen empty empty )$$iterate DispensedId32Generators( each implRamNextIdGen empty empty )$$iterate DispensedId64Generators( each implRamNextIdGen empty empty )$$implRamCreateTable$$implRamReadTableDerivedByPKey$$implRamLockTableDerivedByPKey$$implRamReadAllTableDerived$$implRamReadTableDerivedByIndexes$$implRamReadTableBuffByPKey$$implRamLockTableBuffByPKey$$implRamReadAllTableBuff$$switch PageData yes implRamPageAllTableBuff default empty$$implRamReadTableBuffByIndexes$$switch HasLookupIndex yes implRamReadTableBuffByLookupIndex default empty$$implRamPageTableBuffByIndexes$$switch HasChain yes implRamMoveUpTableBuff default empty$$switch HasChain yes implRamMoveDownTableBuff default empty$$implRamUpdateTable$$implRamDeleteTable$$implRamDeleteTableByInheritedIndexes$$implRamTableReleasePreparedStatements$$iterate ServerMethods( each implServerMethod empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamMoveUpTableBuff">
	$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::moveBuffUp( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaColumnArg )$,
		int32_t revision )
	{
		static const std::string S_ProcName( "moveBuffUp" );
		static const std::string S_CouldNotLocateObject( "Could not locate object" );
		static const std::string S_CouldNotLocateObjectPrev( "Could not locate object.prev" );
		static const std::string S_CouldNotLocateObjectGrandPrev( "Could not locate object.prev.prev" );
		static const std::string S_CouldNotLocateObjectNext( "Could not locate object.next" );

		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* grandprev = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* prev = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* cur = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* next = NULL;

		cur = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each passCommaColumnArg )$);
		if( cur == NULL ) {
			throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
				S_ProcName,
				S_CouldNotLocateObject );
		}

		if( $reference Chain reference PrevRel reference FromIndex iterate Columns( first implRamMoveBuffCurColNull each implRamMoveBuffCurAndColNull )$ ) {
			return( dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( cur ) );
		}

		prev = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference PrevRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaCurCol )$ );
		if( prev == NULL ) {
			delete cur;
			cur = NULL;
			throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
				S_ProcName,
				S_CouldNotLocateObjectPrev );
		}

		if( $reference Chain reference PrevRel reference FromIndex iterate Columns( first implRamMoveBuffPrevColNotNull each implRamMoveBuffPrevAndColNotNull )$ ) {
			grandprev = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference PrevRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaPrevCol )$ );
			if( grandprev == NULL ) {
				delete cur;
				cur = NULL;
				delete prev;
				prev = NULL;
				throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
					S_ProcName,
					S_CouldNotLocateObjectGrandPrev );
			}
		}

		if( $reference Chain reference NextRel reference FromIndex iterate Columns( first implRamMoveBuffCurColNotNull each implRamMoveBuffCurAndColNotNull )$ ) {
			next = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference NextRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaCurCol )$ );
			if( next == NULL ) {
				delete cur;
				cur = NULL;
				delete prev;
				prev = NULL;
				delete grandprev;
				grandprev = NULL;
				throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
					S_ProcName,
					S_CouldNotLocateObjectNext );
			}
		}

		classcode_t classCode = prev-&gt;getClassCode();
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* editPrev = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* editCur = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* editGrandprev = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* editNext = NULL;
		if( grandprev != NULL ) {$reference Chain reference NextRel iterate Columns( each implRamMoveSetGrandprevCur )$$reference Chain reference PrevRel iterate Columns( each implRamMoveSetCurGrandprev )$
		}
		else {$reference Chain reference PrevRel iterate Columns( each implRamMoveSetCurNull )$
		}
$reference Chain reference PrevRel iterate Columns( each implRamMoveSetPrevCur )$
$reference Chain reference NextRel iterate Columns( each implRamMoveSetCurPrev )$

		if( next != NULL ) {$reference Chain reference NextRel iterate Columns( each implRamMoveSetPrevNext )$$reference Chain reference PrevRel iterate Columns( each implRamMoveSetNextPrev )$
		}
		else {$reference Chain reference NextRel iterate Columns( each implRamMoveSetPrevNull )$
		}

		if( grandprev != NULL ) {
			classCode = editGrandprev-&gt;getClassCode();$implRamSchemaMoveBuffUpdateGrandprev$
		}

		classCode = editPrev-&gt;getClassCode();$implRamSchemaMoveBuffUpdatePrev$

		classCode = editCur-&gt;getClassCode();$implRamSchemaMoveBuffUpdateCur$

		if( next != NULL ) {
			classCode = next-&gt;getClassCode();$implRamSchemaMoveBuffUpdateNext$
		}

		if( editPrev != NULL ) {
			delete editPrev;
			editPrev = NULL;
		}
		if( editGrandprev != NULL ) {
			delete editGrandprev;
			editGrandprev = NULL;
		}
		if( editNext != NULL ) {
			delete editNext;
			editNext = NULL;
		}

		return( dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( editCur ) );
	}
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetGrandprevCur">
			grandprev-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( cur-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetCurGrandprev">
			cur-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( grandprev-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetCurNull">
			cur-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetPrevCur">
			prev-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( cur-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetPrevNext">
			prev-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( next-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetPrevNull">
			prev-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetCurPrev">
			cur-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( prev-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetCurNext">
			cur-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( next-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetCurGrandnext">
			cur-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( grandnext-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetNextPrev">
			next-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( prev-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetNextCur">
			next-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( cur-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetNextNull">
			next-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamMoveSetGrandnextCur">
			grandnext-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( cur-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdateCur">
			if( classCode == $reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff::CLASS_CODE ) {
				editCur = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;update$reference Chain reference Table TableName$( Authorization, cur );
			}$reference Chain reference Table iterate TableDeepSubClasses( each implRamSchemaMoveBuffWalkUpdateCur empty empty )$
			else {
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdateCur">
			else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				editCur = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( cur ) ) );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdatePrev">
			if( classCode == $reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff::CLASS_CODE ) {
				editPrev = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;update$reference Chain reference Table TableName$( Authorization, prev );
			}$reference Chain reference Table iterate TableDeepSubClasses( each implRamSchemaMoveBuffWalkUpdatePrev empty empty )$
			else {
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg  );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdatePrev">
			else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				editPrev = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( prev ) ) );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdateNext">
			if( classCode == $reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff::CLASS_CODE ) {
				editNext = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;update$reference Chain reference Table TableName$( Authorization, next );
			}$reference Chain reference Table iterate TableDeepSubClasses( each implRamSchemaMoveBuffWalkUpdateNext empty empty )$
			else {
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdateNext">
			else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				editNext = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( next ) ) );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdateGrandnext">
			if( classCode == $reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff::CLASS_CODE ) {
				editGrandnext = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;update$reference Chain reference Table TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( editGrandnext ) );
			}$reference Chain reference Table iterate TableDeepSubClasses( each implRamSchemaMoveBuffWalkUpdateGrandnext empty empty )$
			else {
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdateGrandnext">
			else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				editGrandnext = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( editGrandnext ) ) );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdateGrandprev">
			if( classCode == $reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff::CLASS_CODE ) {
				editGrandprev = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;update$reference Chain reference Table TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( grandprev ) );
			}$reference Chain reference Table iterate TableDeepSubClasses( each implRamSchemaMoveBuffWalkUpdateGrandprev empty empty )$
			else {
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdateGrandprev">
			else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				editGrandprev = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( grandprev ) ) );
			}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaPrevCol"
		>$switch IsNullable yes implRamMoveBuffPassCommaPrevOptCol default implRamMoveBuffPassCommaPrevReqCol$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaPrevOptCol"
		>, prev-&gt;get$OptionalOrRequired$$Name$Value()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaPrevReqCol"
		>, prev-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaNextCol"
		>$switch IsNullable yes implRamMoveBuffPassCommaNextOptCol default implRamMoveBuffPassCommaNextReqCol$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaNextOptCol"
		>, next-&gt;get$OptionalOrRequired$$Name$Value()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaNextReqCol"
		>, next-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaCurCol"
		>$switch IsNullable yes implRamMoveBuffPassCommaCurOptCol default implRamMoveBuffPassCommaCurReqCol$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaCurOptCol"
		>, cur-&gt;get$OptionalOrRequired$$Name$Value()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaCurReqCol"
		>, cur-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffCurColNull"
		>( cur-&gt;is$OptionalOrRequired$$Name$Null() )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffCurAndColNull">
			&amp;&amp; ( cur-&gt;is$OptionalOrRequired$$Name$Null() )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPrevColNotNull"
		>( ! prev-&gt;is$OptionalOrRequired$$Name$Null() )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPrevAndColNotNull">
			&amp;&amp; ( ! prev-&gt;is$OptionalOrRequired$$Name$Null() )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffCurColNotNull"
		>( ! cur-&gt;is$OptionalOrRequired$$Name$Null() )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffCurAndColNotNull">
			&amp;&amp; ( ! cur-&gt;is$OptionalOrRequired$$Name$Null() )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffNextColNotNull"
		>( ! next-&gt;is$OptionalOrRequired$$Name$Null()  )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffNextAndColNotNull">
			&amp;&amp; ( ! next-&gt;is$OptionalOrRequired$$Name$Null() )</GenRule>

	<GenRule GenDef="IndexCol" Name="passCommaColumnArg"
		>, $Name$</GenRule>

	<GenRule GenDef="Table" Name="implRamMoveDownTableBuff">
	$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::moveBuffDown( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaColumnArg )$,
		int32_t revision )
	{
		const static std::string S_ProcName( "moveBuffDown" );
		const static std::string S_CouldNotLocateObject( "Could not locate object" );
		const static std::string S_CouldNotLocateObjectDotNext( "Could not locate object.next" );
		const static std::string S_CouldNotLocateObjectDotNextDotNext( "Could not locate object.next.next" );
		const static std::string S_CouldNotLocateObjectDotPrev( "Could not locate object.prev" );

		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* prev = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* cur = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* next = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* grandnext = NULL;

		cur = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each passCommaColumnArg )$);
		if( cur == NULL ) {
			throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
				S_ProcName,
				S_CouldNotLocateObject );
		}

		if( $reference Chain reference NextRel reference FromIndex iterate Columns( first implRamMoveBuffCurColNull each implRamMoveBuffCurAndColNull )$ ) {
			return( dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( cur ) );
		}

		next = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference NextRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaCurCol )$ );
		if( next == NULL ) {
			delete cur;
			cur = NULL;
			throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
				S_ProcName,
				S_CouldNotLocateObjectDotNext );
		}

		if( $reference Chain reference NextRel reference FromIndex iterate Columns( first implRamMoveBuffNextColNotNull each implRamMoveBuffNextAndColNotNull )$ ) {
			grandnext = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference NextRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaNextCol )$ );
			if( grandnext == NULL ) {
				delete cur;
				cur = NULL;
				delete next;
				next = NULL;
				throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
					S_ProcName,
					S_CouldNotLocateObjectDotNextDotNext );
			}
		}

		if( $reference Chain reference PrevRel reference FromIndex iterate Columns( first implRamMoveBuffCurColNotNull each implRamMoveBuffCurAndColNotNull )$ ) {
			prev = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference PrevRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaCurCol )$ );
			if( prev == NULL ) {
				delete cur;
				cur = NULL;
				delete next;
				next = NULL;
				delete grandnext;
				grandnext = NULL;
				throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
					S_ProcName,
					S_CouldNotLocateObjectDotPrev );
			}
		}

		classcode_t classCode = cur-&gt;getClassCode();
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* editCur = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* editNext = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* editGrandnext = NULL;
		$reference Chain reference Table CPlusDefNamespace$::$EffSchemaName$$reference Chain reference Table TableName$Buff* editPrev = NULL;

		if( prev != NULL ) {$reference Chain reference NextRel iterate Columns( each implRamMoveSetPrevNext )$$reference Chain reference PrevRel iterate Columns( each implRamMoveSetNextPrev )$
		}
		else {$reference Chain reference PrevRel iterate Columns( each implRamMoveSetNextNull )$
		}
$reference Chain reference PrevRel iterate Columns( each implRamMoveSetCurNext )$
$reference Chain reference NextRel iterate Columns( each implRamMoveSetNextCur )$

		if( editGrandnext != NULL ) {$reference Chain reference NextRel iterate Columns( each implRamMoveSetCurGrandnext )$$reference Chain reference PrevRel iterate Columns( each implRamMoveSetGrandnextCur )$
		}
		else {$reference Chain reference NextRel iterate Columns( each implRamMoveSetCurNull )$
		}

		if( prev != NULL ) {
			classCode = prev-&gt;getClassCode();$implRamSchemaMoveBuffUpdatePrev$
		}

		classCode = cur-&gt;getClassCode();$implRamSchemaMoveBuffUpdateCur$

		classCode = editNext-&gt;getClassCode();$implRamSchemaMoveBuffUpdateNext$

		if( editGrandnext != NULL ) {
			classCode = editGrandnext-&gt;getClassCode();$implRamSchemaMoveBuffUpdateGrandnext$
		}

		if( editPrev != NULL ) {
			delete editPrev;
			editPrev = NULL;
		}
		if( editNext != NULL ) {
			delete editNext;
			editNext = NULL;
		}
		if( editGrandnext != NULL ) {
			delete editGrandnext;
			editGrandnext = NULL;
		}

		return( dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( editCur ) );
	}
</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id16Gen" Name="initRamTableId16Gen">
		id16Generator = new std::map&lt;$SchemaName$Ram$popto Table TableName$Id16Gen, $SchemaName$Ram$popto Table TableName$Id16Gen*&gt;();</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id32Gen" Name="initRamTableId32Gen">
		id32Generator = new std::map&lt;$SchemaName$Ram$popto Table TableName$Id32Gen, $SchemaName$Ram$popto Table TableName$Id32Gen*&gt;();</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id64Gen" Name="initRamTableId64Gen">
		id64Generator = new std::map&lt;$SchemaName$Ram$popto Table TableName$Id64Gen, $SchemaName$Ram$popto Table TableName$Id64Gen*&gt;();</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id16Gen" Name="releaseRamTableId16Gen">
		if( id16Generator != NULL ) {
			$popto Table CPlusNamespace$::$popto Table SchemaName$Ram$popto Table TableName$Id16Gen* elt;
			std::map&lt;$popto Table SchemaName$Ram$popto Table TableName$Id16Gen,
				$popto Table SchemaName$Ram$popto Table TableName$Id16Gen*&gt;::iterator end = id16Generator-&gt;end();
			for( std::map&lt;$popto Table SchemaName$Ram$popto Table TableName$Id16Gen,
					$popto Table SchemaName$Ram$popto Table TableName$Id16Gen*&gt;::iterator cur = id16Generator-&gt;begin();
				cur != end;
				cur ++ )
			{
				if( cur-&gt;second != NULL ) {
					delete cur-&gt;second;
					cur-&gt;second = NULL;
				}
			}
			delete id16Generator;
			id16Generator = NULL;
		}</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id32Gen" Name="releaseRamTableId32Gen">
		if( id32Generator != NULL ) {
			$popto Table CPlusNamespace$::$popto Table SchemaName$Ram$popto Table TableName$Id32Gen* elt;
			std::map&lt;$popto Table SchemaName$Ram$popto Table TableName$Id32Gen,
				$popto Table SchemaName$Ram$popto Table TableName$Id32Gen*&gt;::iterator end = id32Generator-&gt;end();
			for( std::map&lt;$popto Table SchemaName$Ram$popto Table TableName$Id32Gen,
					$popto Table SchemaName$Ram$popto Table TableName$Id32Gen*&gt;::iterator cur = id32Generator-&gt;begin();
				cur != end;
				cur ++ )
			{
				if( cur-&gt;second != NULL ) {
					delete cur-&gt;second;
					cur-&gt;second = NULL;
				}
			}
			delete id32Generator;
			id32Generator = NULL;
		}</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id64Gen" Name="releaseRamTableId64Gen">
		if( id64Generator != NULL ) {
			$popto Table CPlusNamespace$::$popto Table SchemaName$Ram$popto Table TableName$Id64Gen* elt;
			std::map&lt;$popto Table SchemaName$Ram$popto Table TableName$Id64Gen,
				$popto Table SchemaName$Ram$popto Table TableName$Id64Gen*&gt;::iterator end = id64Generator-&gt;end();
			for( std::map&lt;$popto Table SchemaName$Ram$popto Table TableName$Id64Gen,
					$popto Table SchemaName$Ram$popto Table TableName$Id64Gen*&gt;::iterator cur = id64Generator-&gt;begin();
				cur != end;
				cur ++ )
			{
				if( cur-&gt;second != NULL ) {
					delete cur-&gt;second;
					cur-&gt;second = NULL;
				}
			}
			delete id64Generator;
			id64Generator = NULL;
		}</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id16Gen" Name="implRamTableGenerateNextId16">
	int16_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::generateNextId16( $popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( first implRamNextIdGenPKeyArg each implRamNextIdGenCommaPKeyArg )$,
		int16_t argSliceId )
	{
		$popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id16Gen* key = new $popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id16Gen();$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenApplyArgToKey )$
		key-&gt;setRequiredSliceId( argSliceId );

		$popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id16Gen* useGen;
		auto genSearch = id16Generator-&gt;find( *key );
		if( genSearch != id16Generator-&gt;end() ) {
			useGen = genSearch-&gt;second;
			delete key;
			key = NULL;
		}
		else {
			id16Generator-&gt;insert( std::map&lt;$SchemaName$Ram$popto Table TableName$Id16Gen, $SchemaName$Ram$popto Table TableName$Id16Gen*&gt;::value_type( *key, key ) );
			useGen = key;
			key = NULL;
		}

		int16_t retNext = useGen-&gt;getNextId();

		return( retNext );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenApplyArgToKey"
		>$switch IsNullable yes implRamNextIdGenApplyOptArgToKey default implRamNextIdGenApplyReqArgToKey$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenApplyOptArgToKey">
		if( arg$Name$ == NULL ) {
			key-&gt;set$OptionalOrRequired$$Name$Null();
		}
		else {
			key-&gt;set$OptionalOrRequired$$Name$Value( $switch BaseModelAtomClass UuidGen empty UuidDef empty default emitAsterisk$arg$Name$ );
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenApplyReqArgToKey">
		key-&gt;set$OptionalOrRequired$$Name$( arg$Name$ );</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id32Gen" Name="implRamTableGenerateNextId32">
	int32_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::generateNextId32( $popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( first implRamNextIdGenPKeyArg each implRamNextIdGenCommaPKeyArg )$,
		int16_t argSliceId )
	{
		$popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id32Gen* key = new $popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id32Gen();$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenApplyArgToKey )$
		key-&gt;setRequiredSliceId( argSliceId );

		$popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id32Gen* useGen;
		auto genSearch = id32Generator-&gt;find( *key );
		if( genSearch != id32Generator-&gt;end() ) {
			useGen = genSearch-&gt;second;
			delete key;
			key = NULL;
		}
		else {
			id32Generator-&gt;insert( std::map&lt;$SchemaName$Ram$popto Table TableName$Id32Gen, $SchemaName$Ram$popto Table TableName$Id32Gen*&gt;::value_type( *key, key ) );
			useGen = key;
			key = NULL;
		}

		int32_t retNext = useGen-&gt;getNextId();

		return( retNext );
	}
</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id64Gen" Name="implRamTableGenerateNextId64">
	int64_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::generateNextId64( $popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( first implRamNextIdGenPKeyArg each implRamNextIdGenCommaPKeyArg )$,
		int16_t argSliceId )
	{
		$popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id64Gen* key = new $popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id64Gen();$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenApplyArgToKey )$
		key-&gt;setRequiredSliceId( argSliceId );

		$popto Table CPlusNamespace$::$SchemaName$Ram$popto Table TableName$Id64Gen* useGen;
		auto genSearch = id64Generator-&gt;find( *key );
		if( genSearch != id64Generator-&gt;end() ) {
			useGen = genSearch-&gt;second;
			delete key;
			key = NULL;
		}
		else {
			id64Generator-&gt;insert( std::map&lt;$SchemaName$Ram$popto Table TableName$Id64Gen, $SchemaName$Ram$popto Table TableName$Id64Gen*&gt;::value_type( *key, key ) );
			useGen = key;
			key = NULL;
		}

		int64_t retNext = useGen-&gt;getNextId();

		return( retNext );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamTableReleasePreparedStatements">
	void $poptop Table SchemaName$Ram$poptop Table TableName$Table::releasePreparedStatements() {
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableBuffByIndex"
		>$switch IsUnique
			yes implRamReadTableBuffByUniqueIndex
			default implRamReadTableBuffByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamPageTableBuffByIndex"
		>$switch IsUnique
			yes empty
			default maybe_implRamPageTableBuffByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="maybe_implRamPageTableBuffByDuplicateIndex"
		>$switch PageData
			yes implRamPageTableBuffByDuplicateIndex
			default empty$</GenRule>


	<GenRule GenDef="Table" Name="implRamReadTableBuffByLookupIndex"
		>$reference LookupIndex implRamReadTableBuffByLookupIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableBuffByLookupIndex">
	$CPlusDefNamespace$::$DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::readBuffByLookup$declReadTableSuffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnReqArg last empty lone empty )$, $iterate Columns( each empty last declConstAtomType )$ $iterate Columns( each empty last Name )$,
		bool forceRead )
	{
		static const std::string S_ProcName( "readBuffByLookup$declReadTableSuffix$" );
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* buff = readBuffBy$Suffix$( Authorization$iterate Columns( each implRamReadTableBuffCommaPassColArg )$ );
		if( buff == NULL ) {
			return( NULL );
		}
		else if( buff-&gt;getClassCode() == $poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff::CLASS_CODE ) {
			return( dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff ) );
		}
		else {
			delete buff;
			buff = NULL;
			return( NULL );
		}
	}

	$CPlusDefNamespace$::$DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::readDerivedByLookup$declReadTableSuffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnReqArg last empty lone empty )$, $iterate Columns( each empty last declConstAtomType )$ $iterate Columns( each empty last Name )$,
		bool forceRead )
	{
		static const std::string S_ProcName( "readDerivedByLookup$declReadTableSuffix$" );
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* buff = readDerivedBy$Suffix$( Authorization$iterate Columns( each implRamReadTableBuffCommaPassColArg )$ );
		if( buff != NULL ) {
			return( dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff-&gt;clone() ) );
		}
		else {
			return( NULL );
		}
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableDerivedByPKey">
	$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::readDerived( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $reference BaseClass CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey* PKey )
	{
		static const std::string S_ProcName( "readDerived" );
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* buff;
		auto searchDictByPKey = dictByPKey-&gt;find( *PKey );
		if( searchDictByPKey != dictByPKey-&gt;end() ) {
			buff = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( searchDictByPKey-&gt;second );
			if( buff != NULL ) {
				buff = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff-&gt;clone() );
			}
		}
		else {
			buff = NULL;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamLockTableDerivedByPKey">
	$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::lockDerived( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $reference BaseClass CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey* PKey )
	{
		static const std::string S_ProcName( "lockDerived" );
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* buff;
		auto searchDictByPKey = dictByPKey-&gt;find( *PKey );
		if( searchDictByPKey != dictByPKey-&gt;end() ) {
			buff = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( searchDictByPKey-&gt;second );
			if( buff != NULL ) {
				buff = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff-&gt;clone() );
			}
			else {
				dictByPKey-&gt;erase( searchDictByPKey );
				buff = NULL;
			}
		}
		else {
			buff = NULL;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamReadTableSetPKeyAttr"
		>$switch IsNullable yes implRamReadTableSetPKeyOptAttr default implRamReadTableSetPKeyReqAttr$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamReadTableSetPKeyOptAttr">
		key.set$implColumnAttrOptionality$$Name$Value( PKey-&gt;get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamReadTableSetPKeyReqAttr">
		key.set$implColumnAttrOptionality$$Name$( PKey-&gt;get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implRamReadAllTableDerived">
	std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::readAllDerived( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization ) {
		static const std::string S_ProcName( "readAllDerived" );
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; retVec;
		std::map&lt;$reference BaseClass CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey,
			$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::iterator iter = dictByPKey-&gt;begin();
		std::map&lt;$reference BaseClass CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey,
			$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::iterator end = dictByPKey-&gt;end();
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* clone;
		while( iter != end ) {
			clone = dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( iter-&gt;second-&gt;clone() );
			retVec.push_back( clone );
			iter ++;
		}
		return( retVec );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableDerivedByIndexes"
		>$switch HasSuperClassRelation yes implRamReadTableDerivedByInhIndexes default empty$$iterate Index( each implRamReadTableDerivedByThisNonPrimaryIndex )$$reference BaseClass reference PrimaryKeyIndex implRamReadTableDerivedByThisPrimaryIndex$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableDerivedBySubIndexes"
		>$switch HasSuperClassRelation yes implRamReadTableDerivedByInhIndexes default empty$$iterate Index( each implRamReadTableDerivedByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implRamReadTableDerivedByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implRamReadTableDerivedByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableDerivedByInhIndexes"
		>$reference SuperClassRelation reference ToTable implRamReadTableDerivedBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisIndex"
		>$switch IsUnique
			yes implRamReadTableDerivedByThisUniqueIndex
			default implRamReadTableDerivedByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByInhIndex"
		>$switch IsUnique
			yes implRamReadTableDerivedByInhUniqueIndex
			default implRamReadTableDerivedByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByIndex"
		>$switch IsUnique
			yes implRamReadTableDerivedByUniqueIndex
			default implRamReadTableDerivedByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisUniqueIndex">
	$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::readDerivedBy$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		static const std::string S_ProcName( "readDerivedBy$Suffix$" );
		$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key key;$iterate Columns( each implRamReadTableSetKeyAttr )$
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* buff;
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( key );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			buff = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( searchDictBy$Suffix$-&gt;second );
			if( buff != NULL ) {
				buff = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff-&gt;clone() );
			}
		}
		else {
			buff = NULL;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisPrimaryIndex">
	$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::readDerivedBy$reference Table reference BaseClass reference PrimaryKeyIndex Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		static const std::string S_ProcName( "readDerivedBy$reference Table reference BaseClass reference PrimaryKeyIndex Suffix$" );
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table reference BaseClass TableName$PKey key;$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamReadTableSetKeyAttr )$
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* buff;
		auto searchDictByPKey = dictByPKey-&gt;find( key );
		if( searchDictByPKey != dictByPKey-&gt;end() ) {
			buff = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( searchDictByPKey-&gt;second );
			if( buff != NULL ) {
				buff = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff-&gt;clone() );
			}
		}
		else {
			buff = NULL;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByInhUniqueIndex">
	$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::readDerivedBy$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		static const std::string S_ProcName( "readDerivedBy$Suffix$" );
		$reference Table CPlusDefNamespace$::$reference Table DefSchemaName$$reference Table TableName$Buff* buff = schema-&gt;getTable$reference Table TableName$()-&gt;readDerivedBy$Suffix$( Authorization$iterate Columns( each implCommaColPassInvokeIndex )$ );
		if( buff == NULL ) {
			return( NULL );
		}
		else if( buff-&gt;implementsClassCode( $poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff::CLASS_CODE ) ) {
			return( dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff ) );
		}
		else {
			delete buff;
			buff = NULL;
			return( NULL );
		}
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implCommaColPassInvokeIndex">,
			$Name$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisDuplicateIndex">
	std::TCFLibOwningVector&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::readDerivedBy$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		static const std::string S_ProcName( "readDerivedBy$Suffix$" );
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$By$Suffix$Key key;$iterate Columns( each implRamReadTableSetKeyAttr )$
		std::TCFLibOwningVector&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt; recVec;
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* clone;
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( key );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
				 $poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;* subdict$Suffix$ = searchDictBy$Suffix$-&gt;second;
			std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
				$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator iter = subdict$Suffix$-&gt;begin();
			std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
				$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator end = subdict$Suffix$-&gt;end();
			while( iter != end ) {
				clone = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( iter-&gt;second-&gt;clone() );
				recVec.push_back( clone );
				iter ++;
			}
		}
		return( recVec );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByInhDuplicateIndex">
	std::TCFLibOwningVector&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::readDerivedBy$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		static const std::string S_ProcName( "readDerivedBy$Suffix$" );
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$reference Table TableName$Buff*&gt; buffList = schema-&gt;getTable$reference Table TableName$()-&gt;readDerivedBy$Suffix$( Authorization$iterate Columns( each implCommaColPassInvokeIndex )$ );
		$CPlusDefNamespace$::$DefSchemaName$$reference Table TableName$Buff* buff;
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$poptop Table TableName$Buff*&gt; filteredList;
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$reference Table TableName$Buff*&gt;::iterator iterBuffList = buffList.begin();
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$reference Table TableName$Buff*&gt;::iterator endBuffList = buffList.end();
		while( iterBuffList != endBuffList ) {
			buff = *iterBuffList;
			if( ( buff != NULL ) &amp;&amp; ( buff-&gt;implementsClassCode( $poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff::CLASS_CODE ) ) ) {
				*iterBuffList = NULL;
				filteredList.push_back( dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff ) );
			}
			iterBuffList ++;
		}
		return( filteredList );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableBuffByPKey">
	$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::readBuff( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $reference BaseClass CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey* PKey )
	{
		static const std::string S_ProcName( "readBuff" );
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* buff = readDerived( Authorization, PKey );
		if( buff != NULL ) {
			if( buff-&gt;getClassCode() != $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				delete buff;
				buff = NULL;
			}
		}
		return( dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( buff ) );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamLockTableBuffByPKey">
	$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::lockBuff( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey* PKey )
	{
		static const std::string S_ProcName( "lockBuff" );
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* buff = lockDerived( Authorization, PKey );
		return( dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( buff ) );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadAllTableBuff">
	std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::readAllBuff( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization )
	{
		static const std::string S_ProcName( "readAllBuff" );
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* buff;
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; filteredList;
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; buffList = readAllDerived( Authorization );
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::iterator iterBuffList = buffList.begin();
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::iterator endBuffList = buffList.end();
		while( iterBuffList != endBuffList ) {
			buff = *iterBuffList;
			iterBuffList ++;
			if( ( buff != NULL ) &amp;&amp; ( buff-&gt;getClassCode() == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) ) {
				filteredList.push_back( dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff-&gt;clone() ) );
			}
		}
		return( filteredList );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamPageAllTableBuff">
	std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::pageAllBuff( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaOptPriorArg )$ )
	{
		static const std::string S_ProcName( "pageAllBuff" );
		// MSS TODO WORKING
		throw cflib::CFLibNotImplementedYetException( CLASS_NAME, S_ProcName );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamPageTableBuffByDuplicateIndex">
	std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$poptop Table TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::pageBuffBy$declReadTableSuffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaOptPriorArg )$ )
	{
		static const std::string S_ProcName( "pageBuffBy$declReadTableSuffix$" );
		// MSS TODO WORKING
		throw cflib::CFLibNotImplementedYetException( CLASS_NAME, S_ProcName );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableBuffByIndexes"
		>$switch HasSuperClassRelation yes implRamReadTableBuffByInhIndexes default implRamReadTableBuffByBaseIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableBuffByInhIndexes"
		>$reference SuperClassRelation reference ToTable implRamReadTableBuffByIndexes$$iterate Index( each implRamReadTableBuffByNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableBuffByBaseIndexes"
		>$iterate Index( each implRamReadTableBuffByIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableBuffByNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implRamReadTableBuffByIndex$</GenRule>

	<GenRule GenDef="Table" Name="implRamPageTableBuffByIndexes"
		>$switch HasSuperClassRelation yes implRamPageTableBuffByInhIndexes default implRamPageTableBuffByBaseIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamPageTableBuffByInhIndexes"
		>$reference SuperClassRelation reference ToTable implRamPageTableBuffByIndexes$$iterate Index( each implRamPageTableBuffByNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implRamPageTableBuffByBaseIndexes"
		>$iterate Index( each maybe_pagedata_implRamPageTableBuffByIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implRamPageTableBuffByNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default maybe_implRamPageTableBuffByIndex$</GenRule>

	<GenRule GenDef="Index" Name="maybe_pagedata_implRamPageTableBuffByIndex"
		>$switch PageData yes maybe_implRamPageTableBuffByIndex default empty$</GenRule>

	<GenRule GenDef="Index" Name="maybe_implRamPageTableBuffByIndex"
		>$switch IsUnique yes empty default implRamPageTableBuffByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableBuffByUniqueIndex">
	$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::readBuffBy$declReadTableSuffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		static const std::string S_ProcName( "readBuffBy$declReadTableSuffix$" );
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* buff = readDerivedBy$Suffix$( Authorization$iterate Columns( each implRamReadTableBuffCommaPassColArg )$ );
		if( buff == NULL ) {
			return( NULL );
		}
		else if( buff-&gt;getClassCode() == $poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff::CLASS_CODE ) {
			return( dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff ) );
		}
		else {
			delete buff;
			buff = NULL;
			return( NULL );
		}
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableBuffByDuplicateIndex">
	std::TCFLibOwningVector&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::readBuffBy$declReadTableSuffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		static const std::string S_ProcName( "readBuffBy$declReadTableSuffix$" );
		$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* buff;
		std::TCFLibOwningVector&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt; filteredList;
		std::TCFLibOwningVector&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt; buffList = readDerivedBy$Suffix$( Authorization$iterate Columns( each implRamReadTableBuffCommaPassColArg )$ );
		std::TCFLibOwningVector&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator iterBuffList = buffList.begin();
		std::TCFLibOwningVector&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator endBuffList = buffList.end();
		while( iterBuffList != endBuffList ) {
			buff = *iterBuffList;
			iterBuffList ++;
			if( ( buff != NULL ) &amp;&amp; ( buff-&gt;getClassCode() == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) ) {
				filteredList.push_back( dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( buff-&gt;clone() ) );
			}
		}
		return( filteredList );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamReadTableBuffCommaPassColArg">,
			$Name$</GenRule>

	<GenRule GenDef="Table" Name="initRamTableByPKey">
		dictByPKey = new std::map&lt;$reference BaseClass CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;();</GenRule>

	<GenRule GenDef="Object" Name="initRamTableByPKey">
		dictByPKey = new std::map&lt;$reference Table reference BaseClass CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;();</GenRule>

	<GenRule GenDef="Index" Name="maybeInitRamTableByIndex"
		>$switch IsPrimaryIndex yes empty default initRamTableByIndex$</GenRule>

	<GenRule GenDef="Index" Name="initRamTableByIndex"
		>$switch IsUnique yes initRamTableByUniqueIndex default initRamTableByDupIndex$</GenRule>

	<GenRule GenDef="Index" Name="initRamTableByUniqueIndex">
		dictBy$Suffix$ = new std::map&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;();</GenRule>

	<GenRule GenDef="Index" Name="initRamTableByDupIndex">
		dictBy$Suffix$ = new std::map&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key,
			std::map&lt;$reference Table reference BaseClass CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
				$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;*&gt;();</GenRule>

	<GenRule GenDef="Table" Name="releaseRamTableByPKey">
		if( dictByPKey != NULL ) {$switch HasSuperClassRelation yes empty default releaseRamTableByPKeyDataElements$
			delete dictByPKey;
			dictByPKey = NULL;
		}</GenRule>

	<GenRule GenDef="Object" Name="releaseRamTableByPKey">
		if( dictByPKey != NULL ) {$switch HasSuperClassRelation yes empty default releaseRamTableByPKeyDataElements$
			delete dictByPKey;
			dictByPKey = NULL;
		}</GenRule>

	<GenRule GenDef="Table" Name="releaseRamTableByPKeyDataElements">
			$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$Buff* elt;
			std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
				$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$Buff*&gt;::iterator end = dictByPKey-&gt;end();
			for( std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
					$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$Buff*&gt;::iterator cur = dictByPKey-&gt;begin();
				cur != end;
				cur ++ )
			{
				elt = cur-&gt;second;
				if( elt != NULL ) {
					delete elt;
					elt = NULL;
					cur-&gt;second = NULL;
				}
			}</GenRule>

	<GenRule GenDef="Object" Name="releaseRamTableByPKeyDataElements">
			$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$Buff* elt;
			std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
				$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$Buff*&gt;::iterator end = dictByPKey-&gt;end();
			for( std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
					$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$Buff*&gt;::iterator cur = dictByPKey-&gt;begin();
				cur != end;
				cur ++ )
			{
				elt = cur-&gt;second;
				if( elt != NULL ) {
					delete elt;
					elt = NULL;
					cur-&gt;second = NULL;
				}
			}</GenRule>

	<GenRule GenDef="Index" Name="maybeReleaseRamTableByIndex"
		>$switch IsPrimaryIndex yes empty default releaseRamTableByIndex$</GenRule>

	<GenRule GenDef="Index" Name="releaseRamTableByIndex"
		>$switch IsUnique yes releaseRamTableByUniqueIndex default releaseRamTableByDupIndex$</GenRule>

	<GenRule GenDef="Index" Name="releaseRamTableByUniqueIndex">
		if( dictBy$Suffix$ != NULL ) {
			delete dictBy$Suffix$;
			dictBy$Suffix$ = NULL;
		}</GenRule>

	<GenRule GenDef="Index" Name="releaseRamTableByDupIndex">
		if( dictBy$Suffix$ != NULL ) {
			for( auto iterDict = dictBy$Suffix$-&gt;begin(); iterDict != dictBy$Suffix$-&gt;end(); iterDict ++ ) {
				delete iterDict-&gt;second;
				iterDict-&gt;second = NULL;
			}
			delete dictBy$Suffix$;
			dictBy$Suffix$ = NULL;
		}</GenRule>

	<GenRule GenDef="Table" Name="implConstructRamTableTable">
	$poptop Table SchemaName$Ram$poptop Table TableName$Table::$SchemaName$Ram$TableName$Table( I$SchemaName$Schema* argSchema )
	: $CPlusDefNamespace$::I$DefSchemaName$$TableName$Table()
	{
		schema = argSchema;$initRamTableByPKey$$iterate DispensedId16Generators( first initRamTableId16Gen each empty empty empty )$$iterate DispensedId32Generators( first initRamTableId32Gen each empty empty empty )$$iterate DispensedId64Generators( first initRamTableId64Gen each empty empty empty )$$iterate Index( each maybeInitRamTableByIndex )$
	}

	$poptop Table SchemaName$Ram$poptop Table TableName$Table::~$SchemaName$Ram$TableName$Table() {$iterate Index( each maybeReleaseRamTableByIndex )$$iterate DispensedId16Generators( first releaseRamTableId16Gen each empty empty empty )$$iterate DispensedId32Generators( first releaseRamTableId32Gen each empty empty empty )$$iterate DispensedId64Generators( first releaseRamTableId64Gen each empty empty empty )$$releaseRamTableByPKey$
		schema = NULL;
	}
</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id16Gen" Name="implRamNextIdGen">
	int16_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::next$Name$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $popto Table reference BaseClass CPlusDefNamespace$::$popto Table reference BaseClass DefSchemaName$$popto Table reference BaseClass TableName$PKey* pkey )
	{
		int16_t retval = next$Name$( Authorization$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenExtractCommaPKeyArg )$ );
		return( retval );
	}

	int16_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::next$Name$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenCommaPKeyArg )$ )
	{
		int16_t retNext = generateNextId16( $popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( first implRamNextIdGenPassPKeyArg each implRamNextIdGenCommaPassPKeyArg )$,
			(int16_t)$Slice$ );
		return( retNext );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenPassPKeyArg"
		>arg$Name$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenCommaPassPKeyArg">,
		$implRamNextIdGenPassPKeyArg$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenExtractCommaPKeyArg">,
			pkey-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenPKeyArg"
		>$declCPlusAtomType$ arg$Name$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenCommaPKeyArg">,
		$implRamNextIdGenPKeyArg$</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id32Gen" Name="implRamNextIdGen">
	int32_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::next$Name$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $popto Table reference BaseClass CPlusDefNamespace$::$popto Table reference BaseClass DefSchemaName$$popto Table reference BaseClass TableName$PKey* pkey )
	{
		int32_t retval = next$Name$( Authorization$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenExtractCommaPKeyArg )$ );
		return( retval );
	}

	int32_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::next$Name$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenCommaPKeyArg )$ )
	{
		int32_t retNext = generateNextId32( $popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( first implRamNextIdGenPassPKeyArg each implRamNextIdGenCommaPassPKeyArg )$,
			(int16_t)$Slice$ );
		return( retNext );
	}
</GenRule>

	<GenRule ScopeDef="Table" GenDef="Id64Gen" Name="implRamNextIdGen">
	int64_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::next$Name$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $popto Table reference BaseClass CPlusDefNamespace$::$popto Table reference BaseClass DefSchemaName$$popto Table reference BaseClass TableName$PKey* pkey )
	{
		int64_t retval = next$Name$( Authorization$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenExtractCommaPKeyArg )$ );
		return( retval );
	}

	int64_t $poptop Table SchemaName$Ram$poptop Table TableName$Table::next$Name$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamNextIdGenCommaPKeyArg )$ )
	{
		int64_t retNext = generateNextId64( $popto Table reference BaseClass reference PrimaryKeyIndex iterate Columns( first implRamNextIdGenPassPKeyArg each implRamNextIdGenCommaPassPKeyArg )$,
			(int16_t)$Slice$ );
		return( retNext );
	}
</GenRule>

	<GenRule ScopeDef="Table" GenDef="UuidGen" Name="implRamNextIdGen"></GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTablePKeyToBuff">
		Buff-&gt;set$reference Column Optionality$$reference Column Name$( pkey.get$reference Column Optionality$$reference Column Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableCopyBackPKeyToBuff"
		>$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamCreateTablePKeyToBuff )$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTablePKeyGenNew"
		>$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamCreateTablePKey empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTablePKeyCopyBuff"
		>$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamCreateTablePKeyCopyId empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTablePKeyCopyFromBuff"
		>$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamCreateTablePKeyCopyIdFromBuff empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTable">
	$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::create$TableName$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* Buff )
	{
		static const std::string S_ProcName( "create$TableName$" );$switch IsInstantiable yes implRamCreateTableMaybeInitChainLinks default empty$
		$CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey pkey;$switch HasSuperClassRelation no implRamCreateTablePKeyGenNew default implRamCreateTablePKeyCopyBuff$$switch HasSuperClassRelation no implRamCreateTableCopyBackPKeyToBuff default empty$$iterate Index( each maybeImplRamCreateTableInitIndexKey )$
		// Validate unique indexes
		auto searchDictByPKey = dictByPKey-&gt;find( pkey );
		if( searchDictByPKey != dictByPKey-&gt;end() ) {
			delete Buff;
			std::string Msg( "Duplicate primary key detected " + pkey.toString() );
			throw cflib::CFLibPrimaryKeyNotNewException( CLASS_NAME, S_ProcName, Msg );
		}
$iterate Index( each maybeImplRamCreateTableCheckUniqueIndex )$
		// Validate foreign keys
$iterate Relation( each implRamCreateTableIntegrityCheck empty empty )$
		// Proceed with adding the new record$switch HasSuperClassRelation yes implRamCreateTableInvokeSuper default implRamCreateTableCloneBuff$
		dictByPKey-&gt;insert( std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::value_type( pkey, buff ) );
$iterate Index( each maybeImplRamCreateTableAddToIndex )$$switch IsInstantiable yes implRamCreateTableMaybeChainLinkTail default empty$
		// The top level code has to clone the final buffer. The one passed in is now part of the persistent storage.
		if( buff-&gt;getClassCode() == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
			buff = dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( buff-&gt;clone() );
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableMaybeInitChainLinks"
		>$switch HasChain yes implRamCreateTableInitChainLinks default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInitChainLinks"
		>$switch HasClassCode yes implRamCreateTableInitChainLinksWithCC default implRamCreateTableInitChainLinksNoCC$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInitChainLinksWithCC">
		$reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff* tail = NULL;
		if( Buff-&gt;getClassCode() == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {$implRamCreateTableInitChainLinksBody$
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInitChainLinksNoCC">
			$reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff* tail = NULL;
$implRamCreateTableInitChainLinksBody$
		</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInitChainLinksBody">
			std::TCFLibOwningVector&lt;$reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff*&gt; siblings = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference ChainContainerComponents reference ToIndex Suffix$( Authorization$reference ContainerRelation reference FromIndex iterate Columns( each implRamCreateTableInitChainLinksCommaPassArg )$ );
			std::TCFLibOwningVector&lt;$reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff*&gt;::iterator iterSiblings = siblings.begin();
			std::TCFLibOwningVector&lt;$reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff*&gt;::iterator endSiblings = siblings.end();
			while( ( tail == NULL ) &amp;&amp; ( iterSiblings != endSiblings ) ) {
				if( $reference Chain reference NextRel iterate Columns( first implRamCreateTableInitChainLinksCheckNext each implRamCreateTableInitChainLinksCheckAndNext )$ ) {
					tail = *iterSiblings;
				}
				iterSiblings ++;
			}
			if( tail != NULL ) {$reference Chain reference PrevRel iterate Columns( each implRamCreateTableInitChainLinksAssignPrev )$
			}
			else {$reference Chain reference PrevRel iterate Columns( each implRamCreateTableInitChainLinksClearPrev )$
			}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitChainLinksCommaPassArg"
		>$switch IsNullable yes implRamCreateTableInitChainLinksCommaPassOptArg default implRamCreateTableInitChainLinksCommaPassReqArg$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitChainLinksCommaPassOptArg">,
				Buff-&gt;get$OptionalOrRequired$$Name$Reference()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitChainLinksCommaPassReqArg">,
				Buff-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableInitChainLinksClearPrev">
				Buff-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableInitChainLinksAssignPrev">
				Buff-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch FromColIsNullable yes implRamValue default empty$( tail-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableInitChainLinksCheckNext"
		>( (*iterSiblings)-&gt;is$reference FromCol OptionalOrRequired$$reference FromCol Name$Null() )</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableInitChainLinksCheckAndNext">
					&amp;&amp; $implRamCreateTableInitChainLinksCheckNext$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableMaybeChainLinkTail"
		>$switch HasChain yes implRamCreateTableChainLinkTail default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTail"
		>$reference Chain reference Table switch HasClassCode yes implRamCreateTableChainLinkTailWithCC default implRamCreateTableChainLinkTailNoCC$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTailNoCC">
		if( tail != NULL ) {
			tail = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference Chain reference Table reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$reference Chain reference PrevRel iterate Columns( each implRamCreateTableChainTailRetrievePrev )$ );
			$reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff* tailEdit = new $reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff();
			*tailEdit = *dynamic_cast&lt;$reference Chain reference Table CPlusDefNamespace$::$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Buff*&gt;( tail );$reference Chain reference NextRel iterate Columns( each implRamCreateTableChainTailLinkAssignNext )$
			tailEdit = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;update$reference Chain reference Table TableName$( Authorization, tailEdit );
			delete tail;
			tail = NULL;
			delete tailEdit;
			tailEdit = NULL;
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTailWithCC">
		if( tail != NULL ) {
			tail = schema-&gt;getTable$reference Chain reference Table TableName$()-&gt;readDerivedBy$reference Chain reference Table reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$reference Chain reference PrevRel iterate Columns( each implRamCreateTableChainTailRetrievePrev )$ );
			const classcode_t tailClassCode = tail-&gt;getClassCode();
			if( tailClassCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {$implRamCreateTableChainLinkTailBody$
			}$iterate TableDeepSubClasses( each implRamCreateTableChainLinkTailWithCCWalkHierarchy empty empty )$
			else {
				delete Buff;
				delete tail;
				tail = NULL;
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( tailClassCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg );
			}
			delete tail;
			tail = NULL;
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTailWithCCWalkHierarchy">
			else if( tailClassCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {$implRamCreateTableChainLinkTailBody$
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTailBody">
				$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* tailEdit = new $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff();
				*tailEdit = *dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( tail );$reference Chain reference NextRel iterate Columns( each implRamCreateTableChainTailLinkAssignNext )$
				tailEdit = dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, tailEdit ) );
				delete tailEdit;
				tailEdit = NULL;</GenRule>


	<GenRule GenDef="RelationCol" Name="implRamCreateTableChainTailRetrievePrev">,
				buff-&gt;getOptional$reference FromCol Name$Value()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableChainTailLinkAssignNext"
		>$switch IsFromColNullable yes implRamCreateTableChainTailLinkOptAssignNext default implRamCreateTableChainTalLinkReqAssignNext$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableChainTailLinkOptAssignNext"
		>$switch IsToColNullable yes implRamCreateTableChainTailLinkOptAssignOptNext default implRamCreateTableChainTailLinkOptAssignReqNext$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableChainTailLinkOptAssignOptNext">
				if( Buff-&gt;is$reference ToCol OptionalOrRequired$$reference ToCol Name$Null() ) {
					tailEdit-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();
				}
				else {
					tailEdit-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Value( Buff-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$Value() );
				}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableChainTailLinkOptAssignReqNext">
				tailEdit-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Value( Buff-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableChainTailLinkReqAssignNext">
				tailEdit-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$( Buff-&gt;get$reference ToCol OptionalOrRequired$$reference ToCol Name$$switch IsToColNullable yes implRamValue default empty$() );</GenRule>

	<GenRule GenDef="Object" Name="implRamValue">Value</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInvokeSuper">
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* buff = dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( schema-&gt;getTable$reference SuperClassRelation reference ToTable TableName$()-&gt;create$reference SuperClassRelation reference ToTable TableName$( Authorization,
			Buff ) );$implRamCreateTablePKeyCopyFromBuff$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableCloneBuff">
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* buff = Buff;
		buff-&gt;setRequiredRevision( 1 );</GenRule>

	<GenRule GenDef="TableCol" Name="checkPKeyHasValue"
		>$reference DataType checkPKeyHasTableColValue$</GenRule>
	<GenRule GenDef="Atom" Name="checkPKeyHasValue"
		>$checkPKeyHasTableColValue$</GenRule>

	<GenRule GenDef="TableCol" Name="checkHasValue"
		>$reference DataType checkHasTableColValue$</GenRule>
	<GenRule GenDef="Atom" Name="checkHasValue"
		>$checkHasTableColValue$</GenRule>

	<GenRule GenDef="Atom" Name="checkPKeyHasTableColValue"
		>$checkPKeyTypeHasValue$</GenRule>

	<GenRule GenDef="Atom" Name="checkHasTableColValue"
		>$checkTypeHasValue$</GenRule>

	<GenRule GenDef="Object" Name="checkPKeyTypeHasValue"
		>$checkPKeyPointerHasValue$</GenRule>
	<GenRule GenDef="Object" Name="checkPKeyAttrHasValue"
		>( ! pkey.is$Optionality$$Name$Null() )</GenRule>

	<GenRule GenDef="Object" Name="checkTypeHasValue"
		>$checkPointerHasValue$</GenRule>
	<GenRule GenDef="Object" Name="checkAttrHasValue"
		>( ! is$Optionality$$Name$Null() )</GenRule>

	<GenRule GenDef="BoolDef" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Int16Def" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Int32Def" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Int64Def" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Id16Gen" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Id32Gen" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Id64Gen" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="FloatDef" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="DoubleDef" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>

	<GenRule GenDef="BoolDef" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Int16Def" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Int32Def" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Int64Def" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Id16Gen" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Id32Gen" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Id64Gen" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="FloatDef" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="DoubleDef" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>

	<GenRule GenDef="Object" Name="checkPKeyPointerHasValue"
		>pkey.get$Optionality$$Name$() != NULL</GenRule>

	<GenRule GenDef="Object" Name="checkPointerHasValue"
		>( ! is$Optionality$$Name$Null() )</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyValue"
		>$switch IsNullable yes derefPKeyIfNotNull default derefPKeyDirect$</GenRule>
	<GenRule GenDef="Object" Name="derefPKeyIfNotNull"
		>( $switch BaseModelAtomClass
			BoolDef derefPKeyCheckHasValue
			Int16Def derefPKeyCheckHasValue
			Int32Def derefPKeyCheckHasValue
			Int64Def derefPKeyCheckHasValue
			Id16Gen derefPKeyCheckHasValue
			Id32Gen derefPKeyCheckHasValue
			Id64Gen derefPKeyCheckHasValue
			FloatDef derefPKeyCheckHasValue
			DoubleDef derefPKeyCheckHasValue
			default derefPKeyCheckPointerNotNull$ ) ? ( "\\"" + xmlEncodeString( $derefPKeyValue$.ToString() + "\\"" ) : "NULL" </GenRule>

	<GenRule GenDef="Object" Name="derefValue"
		>$switch IsNullable yes derefIfNotNull default derefDirect$</GenRule>
	<GenRule GenDef="Object" Name="derefIfNotNull"
		>( $switch BaseModelAtomClass
			BoolDef derefCheckHasValue
			Int16Def derefCheckHasValue
			Int32Def derefCheckHasValue
			Int64Def derefCheckHasValue
			Id16Gen derefCheckHasValue
			Id32Gen derefCheckHasValue
			Id64Gen derefCheckHasValue
			FloatDef derefCheckHasValue
			DoubleDef derefCheckHasValue
			default derefCheckPointerNotNull$ ) ? ( "\\"" + xmlEncodeString( $derefValue$.ToString() + "\\"" ) : "NULL" </GenRule>

	<GenRule GenDef="Object" Name="derefDotValue"
		>get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Object" Name="derefDotPointer"
		>get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="TableCol" Name="derefPKeyValue"
		>$switch BaseModelAtomClass
			BoolDef derefPKeyDotValue
			Int16Def derefPKeyDotValue
			Int32Def derefPKeyDotValue
			Int64Def derefPKeyDotValue
			Id16Gen derefPKeyDotValue
			Id32Gen derefPKeyDotValue
			Id64Gen derefPKeyDotValue
			FloatDef derefPKeyDotValue
			DoubleDef derefPKeyDotValue
			default derefPKeyDotPointer$</GenRule>

	<GenRule GenDef="Atom" Name="derefPKeyValue"
		>$switch BaseModelAtomClass
			BoolDef derefPKeyDotValue
			Int16Def derefPKeyDotValue
			Int32Def derefPKeyDotValue
			Int64Def derefPKeyDotValue
			Id16Gen derefPKeyDotValue
			Id32Gen derefPKeyDotValue
			Id64Gen derefPKeyDotValue
			FloatDef derefPKeyDotValue
			DoubleDef derefPKeyDotValue
			default derefPKeyDotPointer$</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyDotValue"
		>pkey.get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyDotPointer"
		>pkey.get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Object" Name="derefCheckHasValue"
		>( ! is$Optionality$$Name$Null() )</GenRule>

	<GenRule GenDef="Object" Name="derefCheckPointerNotNull"
		>get$Optionality$$Name$() != NULL</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyCheckHasValue"
		>( ! pkey.is$Optionality$$Name$Null() )</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyCheckPointerNotNull"
		>pkey.get$Optionality$$Name$() != NULL</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyDirect"
		>pkey.get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Object" Name="derefDirect"
		>get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTableIntegrityCheck"
		>$switch RelationTypeTag
			Superclass implRamCreateTableCheckSuperClassReference
			Lookup implRamCreateTableCheckReference
			Master implRamCreateTableCheckReference
			Container implRamCreateTableCheckReference
			Owner implRamCreateTableCheckReference
			default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamCreateTableCheckReference"
		>$switch IsRequired yes implRamCreateTableCheckReqRef default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamCreateTableCheckSuperClassReference"
		></GenRule>
	<GenRule GenDef="Relation" Name="implRamCreateTableCheckReqRef">
		{
			bool allNull = true;$iterate Columns( each implRamCreateTableCheckRefIsNull )$
			if( ! allNull ) {
				$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable Name$Buff* chk = dynamic_cast&lt;$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable Name$Buff*&gt;( schema-&gt;getTable$reference ToTable Name$()-&gt;readDerivedBy$implRamToIndexSuffix$( Authorization$iterate Columns( each implRamCreateTableCheckRefCommaPassArg )$ ) );
				if( chk == NULL ) {
					delete Buff;
					std::string Msg( "Could not resolve $RelationTypeTag$ relationship $Name$ to table $reference ToTable Name$" );
					throw cflib::CFLibUnresolvedRelationException( CLASS_NAME,
						S_ProcName,
						Msg );
				}
				delete chk;
				chk = NULL;
			}
		}
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefIsNull"
		>$switch IsFromColNullable yes implRamCreateTableCheckRefIsOptNull default implRamCreateTableReqIsNotNull$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableReqIsNotNull">
			allNull = false;</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefIsOptNull">
			if( Buff-&gt;is$reference FromCol implColumnAttrOptionality$$reference FromCol Name$Null() ) {
				allNull = false;
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefCommaPassArg">,
						$implRamCreateTableCheckRefPassArg$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefPassArg"
		>$switch IsFromColNullable yes implRamCreateTableCheckRefPassOptArg default implRamCreateTableCheckRefPassReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefPassOptArg"
		>Buff-&gt;get$reference FromCol implColumnAttrOptionality$$reference FromCol Name$Value()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefPassReqArg"
		>Buff-&gt;get$reference FromCol implColumnAttrOptionality$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamCreateTableCheckUniqueIndex"
		>$switch IsPrimaryIndex yes empty default implRamCreateTableCheckUniqueIndex$</GenRule>
	<GenRule GenDef="Index" Name="implRamCreateTableCheckUniqueIndex"
		>$switch IsUnique yes implRamCreateTableReallyCheckUniqueIndex default empty$</GenRule>
	<GenRule GenDef="Index" Name="implRamCreateTableReallyCheckUniqueIndex">
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( key$Suffix$ );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			std::string Msg( "Duplicate key detected for index $Name$ " + key$Suffix$.toString() );
			delete Buff;
			throw cflib::CFLibUniqueIndexViolationException( CLASS_NAME,
				S_ProcName,
				Msg );
		}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableNLAttrNameValue">
				+	"$implColumnAttrOptionality$$Name$=" + $reference Column emitKeyValueString$</GenRule>

	<GenRule GenDef="TableCol" Name="emitKeyValueString"
		>$switch IsNullable yes emitKeyOptValueString default emitKeyReqValueString$</GenRule>
	<GenRule GenDef="Atom" Name="emitKeyValueString"
		>$switch IsNullable yes emitKeyOptValueString default emitKeyReqValueString$</GenRule>

	<GenRule GenDef="TableCol" Name="emitKeyOptValueString"
		>$switch BaseModelAtomClass
			BlobDef emitKeyOptBlobValueString
			BoolDef emitKeyOptBoolValueString
			EnumDef emitKeyOptEnumValueString
			Int16Def emitKeyOptInt16ValueString
			Int32Def emitKeyOptInt32ValueString
			Int64Def emitKeyOptInt64ValueString
			Id16Gen emitKeyOptInt16ValueString
			Id32Gen emitKeyOptInt32ValueString
			Id64Gen emitKeyOptInt64ValueString
			UInt16Def emitKeyOptUInt16ValueString
			UInt32Def emitKeyOptUInt32ValueString
			UInt64Def emitKeyOptUInt64ValueString
			FloatDef emitKeyOptFloatValueString
			DoubleDef emitKeyOptDoubleValueString
			NumberDef emitKeyOptNumberValueString
			StringDef emitKeyOptStringValueString
			TextDef emitKeyOptStringValueString
			TokenDef emitKeyOptStringValueString
			NmTokenDef emitKeyOptStringValueString
			NmTokensDef emitKeyOptStringValueString
			DateDef emitKeyOptDateValueString
			TimeDef emitKeyOptTimeValueString
			TimestampDef emitKeyOptTimestampValueString
			TZDateDef emitKeyOptTZDateValueString
			TZTimeDef emitKeyOptTZTimeValueString
			TZTimestampDef emitKeyOptTZTimestampValueString
			UuidGen emitKeyOptUuidValueString
			UuidDef emitKeyOptUuidValueString
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>
	<GenRule GenDef="Atom" Name="emitKeyOptValueString"
		>$switch BaseModelAtomClass
			BlobDef emitKeyOptBlobValueString
			BoolDef emitKeyOptBoolValueString
			EnumDef emitKeyOptEnumValueString
			Int16Def emitKeyOptInt16ValueString
			Int32Def emitKeyOptInt32ValueString
			Int64Def emitKeyOptInt64ValueString
			Id16Gen emitKeyOptInt16ValueString
			Id32Gen emitKeyOptInt32ValueString
			Id64Gen emitKeyOptInt64ValueString
			UInt16Def emitKeyOptUInt16ValueString
			UInt32Def emitKeyOptUInt32ValueString
			UInt64Def emitKeyOptUInt64ValueString
			FloatDef emitKeyOptFloatValueString
			DoubleDef emitKeyOptDoubleValueString
			NumberDef emitKeyOptNumberValueString
			StringDef emitKeyOptStringValueString
			TextDef emitKeyOptStringValueString
			TokenDef emitKeyOptStringValueString
			NmTokenDef emitKeyOptStringValueString
			NmTokensDef emitKeyOptStringValueString
			DateDef emitKeyOptDateValueString
			TimeDef emitKeyOptTimeValueString
			TimestampDef emitKeyOptTimestampValueString
			TZDateDef emitKeyOptTZDateValueString
			TZTimeDef emitKeyOptTZTimeValueString
			TZTimestampDef emitKeyOptTZTimestampValueString
			UuidGen emitKeyOptUuidValueString
			UuidDef emitKeyOptUuidValueString
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>
	<GenRule GenDef="TableCol" Name="emitKeyReqValueString"
		>$switch BaseModelAtomClass
			BlobDef emitKeyReqBlobValueString
			BoolDef emitKeyReqBoolValueString
			EnumDef emitKeyReqEnumValueString
			Int16Def emitKeyReqInt16ValueString
			Int32Def emitKeyReqInt32ValueString
			Int64Def emitKeyReqInt64ValueString
			Id16Gen emitKeyReqInt16ValueString
			Id32Gen emitKeyReqInt32ValueString
			Id64Gen emitKeyReqInt64ValueString
			UInt16Def emitKeyReqUInt16ValueString
			UInt32Def emitKeyReqUInt32ValueString
			UInt64Def emitKeyReqUInt64ValueString
			FloatDef emitKeyReqFloatValueString
			DoubleDef emitKeyReqDoubleValueString
			NumberDef emitKeyReqNumberValueString
			StringDef emitKeyReqStringValueString
			TextDef emitKeyReqStringValueString
			TokenDef emitKeyReqStringValueString
			NmTokenDef emitKeyReqStringValueString
			NmTokensDef emitKeyReqStringValueString
			DateDef emitKeyReqDateValueString
			TimeDef emitKeyReqTimeValueString
			TimestampDef emitKeyReqTimestampValueString
			TZDateDef emitKeyReqTZDateValueString
			TZTimeDef emitKeyReqTZTimeValueString
			TZTimestampDef emitKeyReqTZTimestampValueString
			UuidGen emitKeyReqUuidValueString
			UuidDef emitKeyReqUuidValueString
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>
	<GenRule GenDef="Atom" Name="emitKeyReqValueString"
		>$switch BaseModelAtomClass
			BlobDef emitKeyReqBlobValueString
			BoolDef emitKeyReqBoolValueString
			EnumDef emitKeyReqEnumValueString
			Int16Def emitKeyReqInt16ValueString
			Int32Def emitKeyReqInt32ValueString
			Int64Def emitKeyReqInt64ValueString
			Id16Gen emitKeyReqInt16ValueString
			Id32Gen emitKeyReqInt32ValueString
			Id64Gen emitKeyReqInt64ValueString
			UInt16Def emitKeyReqUInt16ValueString
			UInt32Def emitKeyReqUInt32ValueString
			UInt64Def emitKeyReqUInt64ValueString
			FloatDef emitKeyReqFloatValueString
			DoubleDef emitKeyReqDoubleValueString
			NumberDef emitKeyReqNumberValueString
			StringDef emitKeyReqStringValueString
			TextDef emitKeyReqStringValueString
			TokenDef emitKeyReqStringValueString
			NmTokenDef emitKeyReqStringValueString
			NmTokensDef emitKeyReqStringValueString
			DateDef emitKeyReqDateValueString
			TimeDef emitKeyReqTimeValueString
			TimestampDef emitKeyReqTimestampValueString
			TZDateDef emitKeyReqTZDateValueString
			TZTimeDef emitKeyReqTZTimeValueString
			TZTimestampDef emitKeyReqTZTimestampValueString
			UuidGen emitKeyReqUuidValueString
			UuidDef emitKeyReqUuidValueString
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>

	<GenRule GenDef="Value" Name="emitKeyReqBlobValueString"
		>new String( Base64.encodeBase64( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() ) )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqBoolValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() ) ? "true" : "false" )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqEnumValueString"
		>Short.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqInt16ValueString"
		>Short.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqInt32ValueString"
		>Integer.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqInt64ValueString"
		>Long.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUInt16ValueString"
		>Integer.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUInt32ValueString"
		>Long.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUInt64ValueString"
		>BigDecimal.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqFloatValueString"
		>Float.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqDoubleValueString"
		>Double.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqNumberValueString"
		>BigNumber.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqStringValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqDateValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTimeValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTimestampValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTZDateValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTZTimeValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTZTimestampValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqObjToStringValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUuidValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>

	<GenRule GenDef="Value" Name="emitKeyOptBlobValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + new String( Base64.encodeBase64( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() ) ) + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptBoolValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : (( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() ) ? "true" : "false" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptEnumValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptInt16ValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptInt32ValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptInt64ValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUInt16ValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUInt32ValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUInt64ValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptFloatValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptDoubleValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptNumberValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptStringValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptDateValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTimeValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTimestampValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTZDateValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTZTimeValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTZTimestampValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUuidValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" )) )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptObjToStringValueString"
		>(( key$popto Index Suffix$.is$implColumnAttrOptionality$$Name$Null() ) ? "NULL" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamCreateTableInitIndexKey"
		>$switch IsPrimaryIndex yes empty default implRamCreateTableInitIndexKey$</GenRule>

	<GenRule GenDef="Index" Name="implRamCreateTableInitIndexKey">
		$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key key$Suffix$;$iterate Columns( each implRamCreateTableInitKeyAttr )$</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamCreateTableAddToIndex"
		>$switch IsPrimaryIndex yes empty default implRamCreateTableAddToIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamCreateTableAddToIndex"
		>$switch IsUnique yes implRamCreateTableAddUniqueKey default implRamCreateTableAddDupKey$</GenRule>

	<GenRule GenDef="Index" Name="implRamCreateTableAddUniqueKey">
		dictBy$Suffix$-&gt;insert( std::map&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::value_type( key$Suffix$, buff ) );
</GenRule>

	<GenRule GenDef="Index" Name="implRamCreateTableAddDupKey">
		std::map&lt;$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;* subdict$Suffix$;
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( key$Suffix$ );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			subdict$Suffix$ = searchDictBy$Suffix$-&gt;second;
		}
		else {
			subdict$Suffix$ = new std::map&lt;$CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;();
			dictBy$Suffix$-&gt;insert( std::map&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key,
				std::map&lt;$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
					$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;*&gt;::value_type( key$Suffix$, subdict$Suffix$ ) );
		}
		subdict$Suffix$-&gt;insert( std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::value_type( pkey, buff ) );
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitKeyAttr"
		>$switch IsNullable yes implRamCreateTableInitKeyOptAttr default implRamCreateTableInitKeyReqAttr$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitKeyOptAttr">
		if( Buff-&gt;is$implColumnAttrOptionality$$Name$Null() ) {
			key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$Null();
		}
		else {
			key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$Value( Buff-&gt;get$implColumnAttrOptionality$$Name$Value() );
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitKeyReqAttr">
		key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( Buff-&gt;get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule ScopeDef="Index" GenDef="IndexCol" Name="implRamCreateTablePKey"
		>$switch GenerateId yes implRamCreateTablePKeyGenId default implRamCreateTablePKeyCopyId$</GenRule>

	<GenRule ScopeDef="Index" GenDef="IndexCol" Name="implRamCreateTablePKeyGenId"
		>$reference Column implRamCreateTablePKeyGenId$</GenRule>

	<GenRule ScopeDef="Index" GenDef="IndexCol" Name="implRamCreateTablePKeyCopyId"
		>$reference Column implRamCreateTableKeysCopyId$</GenRule>

	<GenRule ScopeDef="Index" GenDef="IndexCol" Name="implRamCreateTablePKeyCopyIdFromBuff"
		>$reference Column implRamCreateTableKeysCopyIdFromBuff$</GenRule>

	<GenRule GenDef="TableCol" Name="HasDispenser"
		>$reference DataType HasDispenser$</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenId">$switch HasDispenser yes implRamCreateTablePKeyGenIdInvokeTableNext default implRamCreateTablePKeyGenIdInvokeSchemaNext$</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenIdInvokeTableNext"
		>$switch BaseModelAtomClass UuidGen implRamCreateTablePKeyGenUuidNext default implRamCreateTablePKeyGenIdInvokeTableOtherNext$</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenUuidNext">
		pkey.generate$implColumnAttrOptionality$$Name$();</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenIdInvokeTableOtherNext">
		pkey.set$implColumnAttrOptionality$$Name$( dynamic_cast&lt;$SchemaName$Ram$reference DataType reference Dispenser TableName$Table*&gt;( schema-&gt;getTable$reference DataType reference Dispenser TableName$() )-&gt;next$reference DataType Name$( Authorization$popto Table iterate OnlyOwnerRelations( first implRamCreateTablePKeyGenIdInvokeTableNextPassArgs each empty )$ ) );</GenRule>

	<GenRule GenDef="Object" Name="implRamAsterisk">*</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTablePKeyGenIdInvokeTableNextPassArgs"
		>$reference FromIndex iterate Columns( each implRamCreateTablePKeyGenIdInvokeTableNextCommaPassArg )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTablePKeyGenIdInvokeTableNextCommaPassArg">,
			Buff-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenIdInvokeSchemaNext"
		>$switch BaseModelAtomClass UuidGen implRamCreateTablePKeyGenUuidNext default implRamCreateTablePKeyGenIdInvokeOtherSchemaNext$</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenIdInvokeOtherSchemaNext">
		pkey.set$implColumnAttrOptionality$$Name$( schema-&gt;next$reference DataType Name$() );</GenRule>

	<GenRule GenDef="Atom" Name="implRamCreateTableKeys"
		></GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTablePKeyGenIdInitCols"
		>$iterate Columns( each implRamCreateTablePKeyGenIdInitContainerKeyCol )$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTablePKeyGenIdInitContainerKeyCol"
		>$switch IsFromColNullable yes implRamCreateTablePKeyGenIdInitContainerOptKeyCol default implRamCreateTablePKeyGenIdInitContainerReqKeyCol$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTablePKeyGenIdInitContainerOptKeyCol">
		if( Buff-&gt;is$reference FromCol OptionalOrRequired$$reference FromCol Name$Null() ) {
	 		$leadlower popto TableCol reference DataType reference Dispenser reference BaseClass TableName$PKey-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();
		}
		else {
	 		$leadlower popto TableCol reference DataType reference Dispenser reference BaseClass TableName$PKey-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Value( Buff-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Value() );
		}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTablePKeyGenIdInitContainerReqKeyCol">
	 	$leadlower popto TableCol reference DataType reference Dispenser reference BaseClass TableName$PKey-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$( Buff-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$() );</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTableKeysCopyId">
		pkey.set$implColumnAttrOptionality$$Name$( Buff-&gt;get$switch IsNullable yes implColumnAttrOptional default implColumnAttrRequired$$Name$() );</GenRule>
	<GenRule GenDef="Atom" Name="implRamCreateTableKeysCopyId">
		pkey.set$implColumnAttrOptionality$$Name$( Buff-&gt;get$switch IsNullable yes implColumnAttrOptional default implColumnAttrRequired$$Name$() );</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTableKeysCopyIdFromBuff">
		pkey.set$implColumnAttrOptionality$$Name$( buff-&gt;get$switch IsNullable yes implColumnAttrOptional default implColumnAttrRequired$$Name$() );</GenRule>
	<GenRule GenDef="Atom" Name="implRamCreateTableKeysCopyIdFromBuff">
		pkey.set$implColumnAttrOptionality$$Name$( buff-&gt;get$switch IsNullable yes implColumnAttrOptional default implColumnAttrRequired$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableByPKey">
	$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::read$TableName$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey* PKey )
	{
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* rec;
		auto searchDictByPKey = dictByPKey-&gt;find( *PKey );
		if( searchDictByPKey != dictByPKey-&gt;end() ) {
			rec = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( searchDictByPKey-&gt;second );
			if( rec != NULL ) {
				rec = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( rec-&gt;clone() );
			}
		}
		else {
			rec = NULL;
		}
		return( rec );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadAllTable">
	std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::readAll$TableName$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization )
	{
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff retVec;
		std::map&lt;$CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey,
			$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::iterator iter = dictByPKey-&gt;begin();
		std::map&lt;$CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey,
			$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::iterator end = dictByPKey-&gt;end();
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* clone;
		while( iter != end ) {
			clone = dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( iter-&gt;second-&gt;clone() );
			retVec.push_back( clone );
			iter ++;
		}
		return( retVec );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableByIndex"
		>$switch IsUnique
			yes maybeImplRamReadTableByUniqueIndex
			default implRamReadTableByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamReadTableByUniqueIndex"
		>$switch IsPrimaryIndex yes implRamReadTableByUniquePIndex default implRamReadTableByUniqueIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableByUniquePIndex">
	$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::read$TableName$By$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey key;
$iterate Columns( each implRamReadTableSetKeyAttr )$
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* rec;
		auto searchDictByPKey = dictByPKey-&gt;find( key );
		if( searchDictByPKey != dictByPKey-&gt;end() ) {
			rec = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( searchDictByPKey-&gt;second );
			if( rec != NULL ) {
				rec = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( rec-&gt;clone() );
			}
		}
		else {
			rec = NULL;
		}
		return( rec );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableByUniqueIndex">
	$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::read$TableName$By$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key key;$iterate Columns( each implRamReadTableSetKeyAttr )$
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* rec;
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( key );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			rec = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( searchDictByPKey-&gt;second );
			if( rec != NULL ) {
				rec = dynamic_cast&lt;$poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( rec-&gt;clone() );
			}
		}
		else {
			rec = NULL;
		}
		return( rec );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamReadTableSetKeyAttr"
		>$switch IsNullable yes implRamReadTableSetKeyOptAttr default implRamReadTableSetKeyReqAttr$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamReadTableSetKeyOptAttr">
		if( $Name$ == NULL ) {
			key.set$implColumnAttrOptionality$$Name$Null();
		}
		else {
			key.set$implColumnAttrOptionality$$Name$Value( $switch BaseModelAtomClass UuidGen empty UuidDef empty default emitAsterisk$$Name$ );
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamReadTableSetKeyReqAttr">
		key.set$implColumnAttrOptionality$$Name$( $Name$ );</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableByDuplicateIndex">
	std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; $poptop Table SchemaName$Ram$poptop Table TableName$Table::read$TableName$By$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key key;$iterate Columns( each implRamReadTableSetKeyAttr )$
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; recVec;
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* clone;
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( key );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			std::map&lt;$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
				 $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt; subdict$Suffix$* = searchDictBy$Suffix$-&gt;second;
			std::map&lt;$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
				$reference Table CPlusDefNamespace$::$reference Table DefSchemaName$$reference Table TableName$Buff*&gt;::iterator iter = subdict$Suffix$-&gt;begin();
			std::map&lt;$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
				$reference Table CPlusDefNamespace$::$reference Table DefSchemaName$$reference Table TableName$Buff*&gt;::iterator end = subdict$Suffix$-&gt;end();
			while( iter != end ) {
				clone = dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( iter-&gt;second-&gt;clone() );
				recVec.push_back( clone );
				iter ++;
			}
		}
		else {
			std::map&lt;$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
				 $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;* subdict$Suffix$
					= new std::map&lt;$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
						 $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;();
			dictBy$Suffix$-&gt;insert( std::map&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key,
				std::map&lt;$reference Table CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
					$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;*&gt;::value_type( key, subdict$Suffix$ ) );
		}
		return( recVec );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableCheckRevision">
		if( existing-&gt;getRequiredRevision() != Buff-&gt;getRequiredRevision() ) {
			std::string Msg( "Collision detected for $TableName$ primary key " );
			Msg.append( pkey.toString() );
			Msg.append( " existing revision " );
			Msg.append( std::to_string( existing-&gt;getRequiredRevision() ) );
			Msg.append( " argument buffer revision " );
			Msg.append( std::to_string( Buff-&gt;getRequiredRevision() ) );
			delete Buff;
			throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
				S_ProcName,
				Msg );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTable">
	$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* $poptop Table SchemaName$Ram$poptop Table TableName$Table::update$TableName$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* Buff )
	{
		static const std::string S_ProcName( "update$TableName$" );
		$CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey pkey;$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamUpdateTablePKey empty empty )$$implRamUpdateTableSearchExisting$$switch HasSuperClassRelation no implRamUpdateTableCheckRevision default empty$$iterate Index( each maybeImplRamUpdateTableInitIndexKey )$
		// Check unique indexes
$iterate Index( each maybeImplRamUpdateTableCheckUniqueKey )$
		// Validate foreign keys
$iterate Relation( each implRamUpdateTableIntegrityCheck empty empty )$
		// Update is valid$switch HasSuperClassRelation yes implRamUpdateTableInvokeSuper default empty$
		std::map&lt;$CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;* subdict;
		auto removalDictByPKey = dictByPKey-&gt;find( pkey );
		if( removalDictByPKey != dictByPKey-&gt;end() ) {
			dictByPKey-&gt;erase( removalDictByPKey );
		}$switch HasSuperClassRelation no implRamUpdateTableCopyBuffToExisting default empty$

		dictByPKey-&gt;insert( std::map&lt;$CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::value_type( pkey, existing ) );
$iterate Index( each maybeImplRamUpdateTableReplaceIndexEntry )$

		// The top level code has to clean up the memory buffer that was passed in, and return a clone
		// of the copy that existing buffer that is attached to the RAM storage.  All other cases
		// return the existing buffer.

		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* buff;
		if( existing-&gt;getClassCode() == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
			delete Buff;
			Buff = NULL;
			buff = dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( existing-&gt;clone() );
		}
		else {
			buff = existing;
		}
		return( buff );
	}
</GenRule>

		<GenRule GenDef="Table" Name="implRamUpdateTableSearchExisting">

		// Search for existing buffer

		auto searchExisting = dictByPKey-&gt;find( pkey );
		if( searchExisting == dictByPKey-&gt;end() ) {
			delete Buff;
			std::string Msg( "Existing record not found in $TableName$ for key " + pkey.toString() );
			throw cflib::CFLibStaleCacheDetectedException( CLASS_NAME,
				S_ProcName,
				Msg );
		}

		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* existing = searchExisting-&gt;second;

		if( existing == NULL ) {
			delete Buff;
			static const std::string S_Existing( "existing" );
			throw cflib::CFLibNullArgumentException( CLASS_NAME,
				S_ProcName,
				0,
				S_Existing );
		}

		// Make sure the buffer classes match

		if( existing-&gt;getClassCode() != Buff-&gt;getClassCode() ) {
			static const std::string S_DoesNotMatchExisting( " does not match existing " );
			std::string Msg( "Buffer class " );
			Msg.append( cflib::CFLib::formatClassCode( Buff-&gt;getClassCode() ) );
			Msg.append( S_DoesNotMatchExisting );
			Msg.append( cflib::CFLib::formatClassCode( existing-&gt;getClassCode() ) );
			delete Buff;
			throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
				S_ProcName,
				Msg );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableCopyBuffToExisting">
		// Copy edited buffer to existing persistent buffer
$switch HasSubClasses no implRamUpdateTableCopyBuffToLeafExisting default implRamUpdateTableCopyBuffToHierarchyExisting$
		existing-&gt;setRequiredRevision( existing-&gt;getRequiredRevision() + 1 );</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableCopyBuffToLeafExisting">
		if( Buff-&gt;getClassCode() != $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
			const static std::string S_IsNotA( " is not a $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff" );
			std::string Msg( "Unsupported buffer class " );
			Msg.append( cflib::CFLib::formatClassCode( Buff-&gt;getClassCode() ) );
			Msg.append( S_IsNotA );
			delete Buff;
			throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
				S_ProcName,
				Msg );
		}
		*existing = *Buff;</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableCopyBuffToHierarchyExisting">
		const classcode_t hasClassCode = existing-&gt;getClassCode();
		if( hasClassCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
			*existing = *Buff;
		}$iterate TableDeepSubClasses( each implRamUpdateTableCopyBuffToSubClassExisting empty empty )$
		else {
			const static std::string S_DoesNotDerive( " does not derive from $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff" );
			std::string Msg( "Unsupported buffer class " );
			Msg.append( cflib::CFLib::formatClassCode( hasClassCode ) );
			Msg.append( S_DoesNotDerive );
			delete Buff;
			throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
				S_ProcName,
				Msg );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableCopyBuffToSubClassExisting">
		else if( hasClassCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
			*dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( existing ) = *dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( Buff );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableInvokeSuper">
		existing = dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( schema-&gt;getTable$reference SuperClassRelation reference ToTable TableName$()-&gt;update$reference SuperClassRelation reference ToTable TableName$( Authorization,
			Buff ) );</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTablePKey">
		pkey.set$implColumnAttrOptionality$$Name$( Buff-&gt;get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Relation" Name="implRamUpdateTableIntegrityCheck"
		>$switch RelationTypeTag
			Superclass implRamUpdateTableCheckSuperClassReference
			Lookup implRamUpdateTableCheckReference
			Master implRamUpdateTableCheckReference
			Container implRamUpdateTableCheckReference
			Owner implRamUpdateTableCheckReference
			default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implRamToIndexSuffix"
		>$reference ToIndex implRamIndexSuffix$</GenRule>
	<GenRule GenDef="Index" Name="implRamIndexSuffix"
		>$switch IsPrimaryIndex yes implRamIndexBasePrimarySuffix default Suffix$</GenRule>
	<GenRule GenDef="Index" Name="implRamIndexBasePrimarySuffix"
		>$reference Table reference BaseClass reference PrimaryKeyIndex Suffix$</GenRule>

	<GenRule GenDef="Relation" Name="implRamFromIndexSuffix"
		>$reference FromIndex implRamIndexSuffix$</GenRule>

	<GenRule GenDef="Relation" Name="implRamUpdateTableCheckReference"
		>$switch IsRequired yes implRamUpdateTableCheckReqRef default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamUpdateTableCheckSuperClassReference">
		{
			bool allNull = true;
$iterate Columns( each implRamUpdateTableCheckReqRefColIsNull )$
			if( allNull ) {
				$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable Name$Buff* chk = dynamic_cast&lt;$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable Name$Buff*&gt;( schema-&gt;getTable$reference ToTable Name$()-&gt;readDerivedBy$implRamToIndexSuffix$( Authorization$iterate Columns( each implRamUpdateTableCheckRefCommaPassArg )$ ) );
				if( chk == NULL ) {
					delete Buff;
					std::string Msg( "Could not resolve $RelationTypeTag$ relationship $Name$ to table $reference ToTable Name$" );
					throw cflib::CFLibUnresolvedRelationException( CLASS_NAME,
						S_ProcName,
						Msg );
				}
				delete chk;
				chk = NULL;
			}
		}
</GenRule>

	<GenRule GenDef="Relation" Name="implRamUpdateTableCheckReqRef">
		{
			bool allNull = true;
$iterate Columns( each implRamUpdateTableCheckReqRefColIsNull )$
			if( allNull ) {
				$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable Name$Buff* chk = dynamic_cast&lt;$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable Name$Buff*&gt;( schema-&gt;getTable$reference ToTable Name$()-&gt;readDerivedBy$implRamToIndexSuffix$( Authorization$iterate Columns( each implRamUpdateTableCheckRefCommaPassArg )$ ) );
				if( chk == NULL ) {
					delete Buff;
					std::string Msg( "Could not resolve $RelationTypeTag$ relationship $Name$ to table $reference ToTable Name$" );
					throw cflib::CFLibUnresolvedRelationException( CLASS_NAME,
						S_ProcName,
						Msg );
				}
				delete chk;
				chk = NULL;
			}
		}
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckReqRefColIsNull"
		>$switch IsFromColNullable yes implRamUpdateTableCheckRefColIsOptNull default empty$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefColIsOptNull">
			if( Buff-&gt;is$reference FromCol implColumnAttrOptionality$$reference FromCol Name$Null() ) {
				allNull = false;
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefCommaPassArg">,
						$implRamUpdateTableCheckRefPassArg$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefPassArg"
		>$switch IsToColNullable yes implRamUpdateTableCheckRefPassOptArg default implRamUpdateTableCheckRefPassReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefPassOptArg"
		>Buff-&gt;get$reference FromCol implColumnAttrOptionality$$reference FromCol Name$Value()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefPassReqArg"
		>Buff-&gt;get$reference FromCol implColumnAttrOptionality$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamUpdateTableCheckUniqueKey"
		>$switch IsPrimaryIndex yes empty default implRamUpdateTableCheckUniqueKey$</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableCheckUniqueKey"
		>$switch IsUnique yes implRamUpdateTableReallyCheckUniqueKey default empty$</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableReallyCheckUniqueKey">
		if( existingKey$Suffix$ != newKey$Suffix$ ) {
			auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( newKey$Suffix$ );
			if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
				std::string Msg( "Duplicate key detected for index $IndexName$ " + newKey$Suffix$.toString() );
				delete Buff;
				throw cflib::CFLibUniqueIndexViolationException( CLASS_NAME,
					S_ProcName,
					Msg );
			}
		}
</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamUpdateTableReplaceIndexEntry"
		>$switch IsPrimaryIndex yes empty default implRamUpdateTableReplaceIndexEntry$</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableReplaceIndexEntry"
		>$switch IsUnique yes implRamUpdateTableReplaceUniqueEntry default implRamUpdateTableReplaceDupEntry$</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableReplaceUniqueEntry">
		auto removalDictBy$Suffix$ = dictBy$Suffix$-&gt;find( existingKey$Suffix$ );
		if( removalDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			dictBy$Suffix$-&gt;erase( removalDictBy$Suffix$ );
		}
		dictBy$Suffix$-&gt;insert( std::map&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::value_type( newKey$Suffix$, existing ) );
</GenRule>

	<GenRule GenDef="Index" Name="implRamUpdateTableReplaceDupEntry">
		std::map&lt;$CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
			 $CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;* subdict$Suffix$;
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( existingKey$Suffix$ );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			subdict$Suffix$ = searchDictBy$Suffix$-&gt;second;
			auto searchSubDict = subdict$Suffix$-&gt;find( pkey );
			if( searchSubDict != subdict$Suffix$-&gt;end() ) {
				subdict$Suffix$-&gt;erase( searchSubDict );
			}
			if( subdict$Suffix$-&gt;size() &lt;= 0 ) {
				delete subdict$Suffix$;
				dictBy$Suffix$-&gt;erase( searchDictBy$Suffix$ );
			}
			subdict$Suffix$ = NULL;
		}
		auto searchNewKeyDictBy$Suffix$ = dictBy$Suffix$-&gt;find( newKey$Suffix$ );
		if( searchNewKeyDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			subdict$Suffix$ = searchNewKeyDictBy$Suffix$-&gt;second;
		}
		else {
			subdict$Suffix$ = new std::map&lt;$CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;();
			dictBy$Suffix$-&gt;insert( std::map&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key,
				std::map&lt;$CPlusDefNamespace$::$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,
					$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;*&gt;::value_type( newKey$Suffix$, subdict$Suffix$ ) );
		}
		subdict$Suffix$-&gt;insert( std::map&lt;$CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;::value_type( pkey, existing ) );
</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamUpdateTableInitIndexKey"
		>$switch IsPrimaryIndex yes empty default implRamUpdateTableInitIndexKey$</GenRule>

	<GenRule GenDef="Index" Name="implRamUpdateTableInitIndexKey">
		$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key existingKey$Suffix$;$iterate Columns( each implRamUpdateTableInitExistingKeyAttr )$
		$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key newKey$Suffix$;$iterate Columns( each implRamUpdateTableInitNewKeyAttr )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTableInitExistingKeyAttr"
		>$switch IsNullable yes implRamUpdateTableInitExistingKeyOptAttr default implRamUpdateTableInitExistingKeyReqAttr$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTableInitExistingKeyOptAttr">
		if( existing-&gt;is$implColumnAttrOptionality$$Name$Null() ) {
			existingKey$popto Index Suffix$.set$implColumnAttrOptionality$$Name$Null();
		}
		else {
			existingKey$popto Index Suffix$.set$implColumnAttrOptionality$$Name$Value( existing-&gt;get$implColumnAttrOptionality$$Name$Value() );
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTableInitExistingKeyReqAttr">
		existingKey$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( existing-&gt;get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTableInitNewKeyAttr"
		>$switch IsNullable yes implRamUpdateTableInitNewKeyOptAttr default implRamUpdateTableInitNewKeyReqAttr$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTableInitNewKeyOptAttr">
		if( Buff-&gt;is$implColumnAttrOptionality$$Name$Null() ) {
			newKey$popto Index Suffix$.set$implColumnAttrOptionality$$Name$Null();
		}
		else {
			newKey$popto Index Suffix$.set$implColumnAttrOptionality$$Name$Value( Buff-&gt;get$implColumnAttrOptionality$$Name$Value() );
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTableInitNewKeyReqAttr">
		newKey$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( Buff-&gt;get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableByInheritedIndexes"
		>$switch HasSuperClassRelation yes implRamDeleteTableByInhIndexes default implRamDeleteTableByBaseIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableByInhIndexes"
		>$iterate Index( each implRamDeleteTableByNonPrimaryIndex empty empty )$$reference SuperClassRelation reference ToTable implRamDeleteTableByInheritedIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableByBaseIndexes"
		>$iterate Index( each implRamDeleteTableBySpecialIndex empty empty )$</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableByNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implRamDeleteTableByIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableBySpecialIndex"
		>$switch IsPrimaryIndex yes implRamDeleteTableByPrimaryIndex default implRamDeleteTableByIndex$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableCheckRevision">
		if( existing-&gt;getRequiredRevision() != Buff-&gt;getRequiredRevision() ) {
			std::string Msg( "Collision detected for $TableName$ primary key " );
			Msg.append( pkey.toString() );
			Msg.append( " existing revision " );
			Msg.append( std::to_string( existing-&gt;getRequiredRevision() ) );
			Msg.append( " argument buffer revision " );
			Msg.append( std::to_string( Buff-&gt;getRequiredRevision() ) );
			throw cflib::CFLibCollisionDetectedException( CLASS_NAME,
				S_ProcName,
				Msg );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTable">
	void $poptop Table SchemaName$Ram$poptop Table TableName$Table::delete$TableName$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* Buff )
	{
		static const std::string S_ProcName( "delete$TableName$" );
		static const std::string S_Prev( "prev" );
		classcode_t classCode;
		$CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey pkey;$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamUpdateTablePKey empty empty )$
		auto searchExisting = dictByPKey-&gt;find( pkey );
		if( searchExisting == dictByPKey-&gt;end() ) {
			return;
		}
		$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff* existing = searchExisting-&gt;second;<!--Would require ugly record re-read code for all result set processing.  Slow, too. $implRamDeleteTableCheckRevision$-->$switch ThisHasChain yes implRamDeleteTableChainSelectChainLinks default empty$$switch ThisHasChain yes implRamDeleteTableUpdatePrev default empty$$switch ThisHasChain yes implRamDeleteTableUpdateNext default empty$$implRamDeleteTableClearDeps$$switch ClassHierarchyHasSubObjectLookup yes implRamDeleteTableClearRootSubObjectRefs default empty$$switch HasDelDeps no implRamDeleteCascades default implRamDeleteTableDelDeps$$iterate Index( each maybeImplRamDeleteTableInitIndexKey )$
		// Validate reverse foreign keys
$iterate ReverseRelations( each implRamDeleteTableIntegrityCheck empty empty )$
		// Delete is valid
		std::map&lt;$CPlusDefNamespace$::$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey, $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;* subdict;

		auto searchDictByPKey = dictByPKey-&gt;find( pkey );
		if( searchDictByPKey != dictByPKey-&gt;end() ) {
			dictByPKey-&gt;erase( searchDictByPKey );
		}
$iterate Index( each maybeImplRamDeleteTableRemoveIndexEntry )$$switch HasSuperClassRelation yes implRamDeleteTableInvokeSuper default empty$$switch HasSuperClassRelation yes empty default implDeleteTableDeleteExisting$
	}
</GenRule>

	<GenRule GenDef="Table" Name="implDeleteTableDeleteExisting">
		if( existing != NULL ) {
			delete existing;
			existing = NULL;
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteCascades"
		>$implRamReallyDeleteCascades$</GenRule>

	<GenRule GenDef="Table" Name="implRamReallyDeleteCascades"
		>$iterate Relation( each implRamDeleteCascadeRelation empty empty )$$switch HasSuperClassRelation yes implRamDeleteSuperCascades default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteSuperCascades"
		>$reference SuperClassRelation reference ToTable implRamReallyDeleteCascades$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteCascadeRelation"
		>$switch RelationTypeTag
			Components implRamDeleteCascade
			Children implRamDeleteCascade
			Details implRamDeleteCascade
			default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteCascade"
		>$switch ToIndexIsUnique yes implRamDeleteCascadeSingleton default implRamDeleteCascadeMany$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteCascadeSingleton">
		{
			$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable Name$Buff* chk = dynamic_cast&lt;$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable Name$Buff*&gt;( schema-&gt;getTable$reference ToTable TableName$()-&gt;readDerivedBy$reference ToIndex Suffix$( Authorization$iterate Columns( each implRamDeleteTableDelExistingPassArg )$ ) );
			if( chk != NULL ) {
				delete chk;
				chk = NULL;
				schema-&gt;getTable$reference ToTable TableName$()-&gt;delete$reference ToTable TableName$By$reference ToIndex Suffix$( Authorization$iterate Columns( each implRamDeleteTableDelExistingPassArg )$ );
			}
		}</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteCascadeMany">
		std::TCFLibOwningVector&lt;$reference ToTable CPlusDefNamespace$::$reference ToTable DefSchemaName$$reference ToTable TableName$Buff*&gt; arrCheck$Name$ = schema-&gt;getTable$reference ToTable TableName$()-&gt;readDerivedBy$reference ToIndex Suffix$( Authorization$iterate Columns( each implRamDeleteTableDelExistingPassArg )$ );
		if( arrCheck$Name$.size() &gt; 0 ) {
			schema-&gt;getTable$reference ToTable TableName$()-&gt;delete$reference ToTable TableName$By$reference ToIndex Suffix$( Authorization$iterate Columns( each implRamDeleteTableDelExistingPassArg )$ );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableDelDeps"
		>$implRamReallyDeleteTableDelDeps$</GenRule>

	<GenRule GenDef="Table" Name="implRamReallyDeleteTableDelDeps"
		>$switch HasSuperClassRelation yes implRamDeleteTableInhDelDeps default implRamDeleteTableBaseDelDeps$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableInhDelDeps"
		>$iterate ReverseDelDeps( each implRamDeleteTableDelDep empty empty )$$reference SuperClassRelation reference ToTable implRamReallyDeleteTableDelDeps$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableBaseDelDeps"
		>$iterate ReverseDelDeps( each implRamDeleteTableDelDep empty empty )$</GenRule>

	<GenRule GenDef="DelDep" Name="RelationIsUnique"
		>$reference Relation IsUnique$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelDep"
		>$switch RelationIsUnique yes implRamDeleteTableDelUniqueDep default implRamDeleteTableDelDupDep$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelUniqueDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelUniqueDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelDupDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelDupDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelThisOne">
		schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;delete$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTableDelExistingPassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelExistingPassArg"
		>$switch ToColIsNullable yes implRamDeleteTableDelExistingPassOptArg default implRamDeleteTableDelExistingPassReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelExistingPassOptArg">,
			existing-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelExistingPassReqArg">,
			existing-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelUniqueDepChaseDown">
		$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaExistingArg )$ );
		if( buff$Name$ != NULL ) {$reference DelSubDep implRamDeleteTableDelDep$
			delete buff$Name$;
			buff$Name$ = NULL;
		}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaExistingArg"
		>$switch IsToColNullable yes implRamDeleteTablePassCommaExistingOptArg default implRamDeleteTablePassCommaExistingReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaExistingOptArg">,
			existing-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaExistingReqArg">,
			existing-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelDupDepChaseDown">
		$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$;
		std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt; arr$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaExistingArg )$ );
		std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator iterArr$Name$ = arr$Name$.begin();
		std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator endArr$Name$ = arr$Name$.end();
		while( iterArr$Name$ != endArr$Name$ ) {
			buff$Name$ = *iterArr$Name$;
			iterArr$Name$ ++;$reference DelSubDep implRamDeleteTableDelDep$
		}</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelDep"
		>$switch RelationIsUnique yes implRamDeleteTableDelUniqueDep default implRamDeleteTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelUniqueDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelUniqueDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelDupDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelDupDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelThisOne">
			schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;delete$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTableDelTopDepPassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelTopDepPassArg"
		>$switch IsToColNullable yes implRamDeleteTableDelTopDepPassOptArg default implRamDeleteTableDelTopDepPassReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelTopDepPassOptArg">,
				buff$popto DelTopDep Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelTopDepPassReqArg">,
				buff$popto DelTopDep Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelUniqueDepChaseDown">
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference FromIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelTopDepArg )$ );
			if( buff$Name$ != NULL ) {$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelTopDepArg"
		>$switch IsToColNullable yes implRamDeleteTablePassCommaDelTopDepOptArg default implRamDeleteTablePassCommaDelTopDepReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelTopDepOptArg">,
				buff$popto DelTopDep Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelTopDepReqArg">,
				buff$popto DelTopDep Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelDupDepChaseDown">
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$;
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt; arr$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelTopDepArg )$ );
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator iterArr$Name$ = arr$Name$.begin();
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator endArr$Name$ = arr$Name$.end();
			while( iterArr$Name$ != endArr$Name$ ) {
				buff$Name$ = *iterArr$Name$;
				iterArr$Name$ ++;$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelDep"
		>$switch RelationIsUnique yes implRamDeleteTableDelUniqueDep default implRamDeleteTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelUniqueDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelUniqueDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelDupDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelDupDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelThisOne">
			schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;delete$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTableDelSubDep1PassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelSubDep1PassArg"
		>$switch IsToColNullable yes implRamDeleteTableDelSubDep1PassOptArg default implRamDeleteTableDelSubDep1PassReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelSubDep1PassOptArg">,
				buff$popto DelSubDep1 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelSubDep1PassReqArg">,
				buff$popto DelSubDep1 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelSubDep1Arg"
		>$switch IsToColNullable yes implRamDeleteTablePassCommaDelSubDep1OptArg default implRamDeleteTablePassCommaDelSubDep1ReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelSubDep1OptArg">,
				buff$popto DelSubDep1 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelSubDep1ReqArg">,
				buff$popto DelSubDep1 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelUniqueDepChaseDown">
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference FromIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelSubDep1Arg )$ );
			if( buff$Name$ != NULL ) {$reference DelSubDep implRamDeleteTableDelDep$
				delete buff$Name$;
				buff$Name$ = NULL;
			}</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelDupDepChaseDown">
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$;
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt; arr$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelSubDep1Arg )$ );
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator iter$Name$ = arr$Name$.begin();
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator end$Name$ = arr$Name$.end();
			while( iter$Name$ != end$Name$ ) {
				buff$Name$ = *iter$Name$;
				iter$Name$ ++;$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelDep"
		>$switch RelationIsUnique yes implRamDeleteTableDelUniqueDep default implRamDeleteTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelUniqueDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelUniqueDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelDupDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelDupDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelThisOne">
			schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;delete$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTableDelSubDep2PassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelSubDep2PassArg"
		>$switch IsToColNullable yes implRamDeleteTableDelSubDep2PassOptArg default implRamDeleteTableDelSubDep2PassReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelSubDep2PassOptArg">,
				buff$popto DelSubDep2 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelSubDep2PassReqArg">,
				buff$popto DelSubDep2 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelUniqueDepChaseDown">
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference FromIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelSubDep2Arg )$ );
			if( buff$Name$ != NULL ) {$reference DelSubDep implRamDeleteTableDelDep$
				delete buff$Name$;
				buff$Name$ = NULL;
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelSubDep2Arg"
		>$switch IsToColNullable yes implRamDeleteTablePassCommaDelSubDep2OptArg default implRamDeleteTablePassCommaDelSubDep2ReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelSubDep2OptArg">,
				buff$popto DelSubDep2 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelSubDep2ReqArg">,
				buff$popto DelSubDep2 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelDupDepChaseDown">
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$;
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt; arr$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelSubDep2Arg )$ );
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator iter$Name$ = arr$Name$.begin();
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator end$Name$ = arr$Name$.end();
			while( iter$Name$ != end$Name$ ) {
				buff$Name$ = *iter$Name$;
				iter$Name$ ++;$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearRootSubObjectExistingArg">,
			existing-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearRootSubObjectRefs">
		$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff* editSubobj = NULL;
		$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff* subobj = schema-&gt;getTable$TableName$()-&gt;readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearRootSubObjectExistingArg )$ );$implRamDeleteTableClearSubObjectRefs$
		classCode = subobj-&gt;getClassCode();
		if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
			editSubobj = dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, subobj ) );
		}$iterate TableDeepSubClasses( each implRamDeleteTableSubObjectWalkSaveEditBuff empty empty )$
		else {
			delete subobj;
			subobj = NULL;
			std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
			throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
				S_ProcName,
				S_Msg );
		}
		// existing was not deleted by the update, so we won't be deleting that
		// unless we're in the base class.  But we may as well delete editSubobj
		// now because we always have to get rid of it.
		delete editSubobj;
		editSubobj = NULL;</GenRule>

	<GenRule GenDef="Table" Name="ClassHierarchyHasSubObjectLookup"
		>$switch MaybeHasSubObjectLookup empty no default yes$</GenRule>

	<GenRule GenDef="Table" Name="MaybeHasSubObjectLookup"
		>$switch HasSubObjectLookup yes yes default empty$$switch HasSuperClassRelation yes InhMaybeHasSubObjectLookup default empty$</GenRule>

	<GenRule GenDef="Table" Name="InhMaybeHasSubObjectLookup"
		>$reference SuperClassRelation reference ToTable MaybeHasSubObjectLookup$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearSubObjectRefs"
		>$switch HasSuperClassRelation yes implRamDeleteTableInhClearSubObjectRefs default implRamDeleteTableBaseClearSubObjectRefs$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableInhClearSubObjectRefs"
		>$reference SuperClassRelation reference ToTable implRamDeleteTableClearSubObjectRefs$$switch HasSubObjectLookup yes implRamDeleteTableClearSubObjectLookups default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableBaseClearSubObjectRefs"
		>$switch HasSubObjectLookup yes implRamDeleteTableClearSubObjectLookups default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearSubObjectLookups"
		>$iterate Relation( each implRamDeleteTableClearSubObjectLookupCols empty empty )$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableClearSubObjectLookupCols"
			>$switch IsSubObjectLookup yes implRamDeleteTableReallyClearSubObjectLookupCols default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableReallyClearSubObjectLookupCols"
			>$iterate Columns( each implRamDeleteTableClearSubObjectFromCol )$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableClearSubObjectFromCol">
			subobj-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableSubObjectWalkSaveEditBuff">
		else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
			editSubobj = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( subobj ) ) );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearDeps"
		>$switch HasSuperClassRelation yes implRamDeleteTableInhClearDeps default implRamDeleteTableBaseClearDeps$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableInhClearDeps"
		>$reference SuperClassRelation reference ToTable implRamDeleteTableClearDeps$$iterate ReverseClearDeps( each implRamDeleteTableClearDep empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableBaseClearDeps"
		>$iterate ReverseClearDeps( each implRamDeleteTableClearDep empty empty )$</GenRule>

	<GenRule GenDef="ClearDep" Name="RelationIsUnique"
		>$reference Relation IsUnique$</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearDep"
		>$switch RelationIsUnique yes implRamDeleteTableClearUniqueDep default implRamDeleteTableClearDupDep$</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearUniqueDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearUniqueDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearDupDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearDupDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearPassExistingArg">,
						existing-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearThisOne">
					{
						$reference Relation reference FromTable CPlusDefNamespace$::$reference Relation reference FromTable EffSchemaName$$reference Relation reference FromTable Name$Buff* buff = schema-&gt;getTable$reference Relation reference FromTable TableName$()-&gt;readDerivedBy$reference Relation reference FromTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$reference Relation reference FromTable reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearPassExistingArg )$ );$reference Relation iterate Columns( each implRamDeleteTableClearRelationFromAttr empty empty )$
						$reference Relation reference FromTable CPlusDefNamespace$::$reference Relation reference FromTable EffSchemaName$$reference Relation reference FromTable Name$Buff* editBuff = NULL;
						classCode = buff-&gt;getClassCode();
						if( classCode == $reference Relation reference FromTable CPlusDefNamespace$::$reference Relation reference FromTable DefSchemaName$$reference Relation reference FromTable TableName$Buff::CLASS_CODE ) {
							editBuff = dynamic_cast&lt;$reference Relation reference FromTable CPlusDefNamespace$::$reference Relation reference FromTable EffSchemaName$$reference Relation reference FromTable Name$Buff*&gt;( schema-&gt;getTable$reference Relation reference FromTable TableName$()-&gt;update$popto ClearTopDep reference Relation reference FromTable TableName$( Authorization, buff ) );
						}$reference Relation reference FromTable iterate TableDeepSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$
						else {
							if( buff != NULL ) {
								delete buff;
								buff = NULL;
							}
							std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
							throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
								S_ProcName,
								S_Msg );
						}
						if( editBuff != NULL ) {
							delete editBuff;
							editBuff = NULL;
						}
					}</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearUniqueDepChaseDown">
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* editBuff$Name$ = NULL;
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaExistingArg )$ );
			if( buff$Name$ != NULL ) {$reference ClearSubDep implRamDeleteTableClearDep$
				delete buff$Name$;
				buff$Name$ = NULL;
			}</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearDupDepChaseDown">
			$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$;
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt; arr$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaExistingArg )$ );
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator iter$Name$ = arr$Name$.begin();
			std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator end$Name$ = arr$Name$.end();
			while( iter$Name$ != end$Name$ ) {
				buff$Name$ = *iter$Name$;
				iter$Name$ ++;$reference ClearSubDep implRamDeleteTableClearDep$
			}</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearDep"
		>$switch RelationIsUnique yes implRamDeleteTableClearUniqueDep default implRamDeleteTableClearDupDep$</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearUniqueDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearUniqueDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearDupDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearDupDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearPassTopDepArg">,
							buff$popto ClearTopDep Name$-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearThisOne">
					{
						$popto ClearTopDep reference Relation reference ToTable CPlusDefNamespace$::$popto ClearTopDep reference Relation reference ToTable EffSchemaName$$popto ClearTopDep reference Relation reference ToTable Name$Buff* editBuff = NULL;
						$popto ClearTopDep reference Relation reference ToTable CPlusDefNamespace$::$popto ClearTopDep reference Relation reference ToTable EffSchemaName$$popto ClearTopDep reference Relation reference ToTable Name$Buff* buff = schema-&gt;getTable$popto ClearTopDep reference Relation reference ToTable TableName$()-&gt;readDerivedBy$popto ClearTopDep reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$popto ClearTopDep reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearPassTopDepArg )$ );$reference Relation iterate Columns( each implRamDeleteTableClearRelationFromAttr empty empty )$
						classCode = buff-&gt;getClassCode();
						if( classCode == $popto ClearTopDep reference Relation reference ToTable CPlusDefNamespace$::$popto ClearTopDep reference Relation reference ToTable DefSchemaName$$popto ClearTopDep reference Relation reference ToTable TableName$Buff::CLASS_CODE ) {
							editBuff = dynamic_cast&lt;$popto ClearTopDep reference Relation reference ToTable CPlusDefNamespace$::$popto ClearTopDep reference Relation reference ToTable EffSchemaName$$popto ClearTopDep reference Relation reference ToTable Name$Buff*&gt;( schema-&gt;getTable$popto ClearTopDep reference Relation reference ToTable TableName$()-&gt;update$popto ClearTopDep reference Relation reference ToTable TableName$( Authorization, buff ) );
						}$popto ClearTopDep reference Relation reference ToTable iterate TableDeepSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$
						else {
							if( buff != NULL ) {
								delete buff;
								buff = NULL;
							}
							std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
							throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
								S_ProcName,
								S_Msg );
						}
						if( editBuff != NULL ) {
							delete editBuff;
							editBuff = NULL;
						}
					}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaClearTopDepArg"
		>$switch IsToColNullable yes implRamDeleteTablePassCommaClearTopDepOptArg default implRamDeleteTablePassCommaClearTopDepReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaClearTopDepOptArg">,
				buff$popto ClearTopDep Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaClearTopDepReqArg">,
				buff$popto ClearTopDep Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearUniqueDepChaseDown">
				$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference FromIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaClearTopDepArg )$ );
				if( buff$Name$ != NULL ) {$reference ClearSubDep implRamDeleteTableClearDep$
					delete buff$Name$;
					buff$Name$ = NULL;
				}</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearDupDepChaseDown">
				$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$;
				std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt; arr$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaClearTopDepArg )$ );
				std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator iter$Name$ = arr$Name$.begin();
				std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator end$Name$ = arr$Name$.end();
				while( iter$Name$ != end$Name$ ) {
					buff$Name$ = *iter$Name$;
					iter$Name$ ++;$reference ClearSubDep implRamDeleteTableClearDep$
				}</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearDep"
		>$switch RelationIsUnique yes implRamDeleteTableClearUniqueDep default implRamDeleteTableClearDupDep$</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearUniqueDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearUniqueDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearDupDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearDupDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearPassSubDep1Arg">,
							buff$popto ClearSubDep1 Name$-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearThisOne">
					{
						$popto ClearSubDep1 reference Relation reference ToTable CPlusDefNamespace$::$popto ClearSubDep1 reference Relation reference ToTable EffSchemaName$$popto ClearSubDep1 reference Relation reference ToTable Name$Buff* editBuff = NULL;
						$popto ClearSubDep1 reference Relation reference ToTable CPlusDefNamespace$::$popto ClearSubDep1 reference Relation reference ToTable EffSchemaName$$popto ClearSubDep1 reference Relation reference ToTable Name$Buff* buff = schema-&gt;getTable$popto ClearSubDep1 reference Relation reference ToTable TableName$()-&gt;readDerivedBy$popto ClearSubDep1 reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$popto ClearSubDep1 reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearPassSubDep1Arg )$ );$reference Relation iterate Columns( each implRamDeleteTableClearRelationFromAttr empty empty )$
						classCode = buff-&gt;getClassCode();
						if( classCode == $poptop ClearSubDep1 reference Relation reference ToTable CPlusDefNamespace$::$poptop ClearSubDep1 reference Relation reference ToTable DefSchemaName$$popto ClearSubDep1 reference Relation reference ToTable TableName$Buff::CLASS_CODE ) {
							editBuff = dynamic_cast&lt;$popto ClearSubDep1 reference Relation reference ToTable CPlusDefNamespace$::$popto ClearSubDep1 reference Relation reference ToTable EffSchemaName$$popto ClearSubDep1 reference Relation reference ToTable Name$Buff*&gt;( schema-&gt;getTable$popto ClearSubDep1 reference Relation reference ToTable TableName$()-&gt;update$popto ClearSubDep1 reference Relation reference ToTable TableName$( Authorization, buff ) );
						}$popto ClearSubDep1 reference Relation reference ToTable iterate TableDeepSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$
						else {
							if( buff != NULL ) {
								delete buff;
								buff = NULL;
							}
							std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
							throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
								S_ProcName,
								S_Msg );
						}
						if( editBuff != NULL ) {
							delete editBuff;
							editBuff = NULL;
						}
					}</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearUniqueDepChaseDown">
					$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaClearSubDep1Arg )$ );
					if( buff$Name$ != NULL ) {$reference ClearSubDep implRamDeleteTableClearDep$
						delete buff$Name$;
						buff$Name$ = NULL;
					}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaClearSubDep1Arg"
		>$switch IsToColNullable yes implRamDeleteTablePassCommaClearSubDep1OptArg default implRamDeleteTablePassCommaClearSubDep1ReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaClearSubDep1OptArg">,
						buff$popto ClearSubDep1 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaClearSubDep1ReqArg">,
						buff$popto ClearSubDep1 Name$-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$()</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearDupDepChaseDown">
					$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff* buff$Name$;
					std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt; arr$Name$ = schema-&gt;getTable$reference Relation reference ToTable TableName$()-&gt;readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaClearSubDep1Arg )$ );
					std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator iter$Name$ = arr$Name$.begin();
					std::TCFLibOwningVector&lt;$reference Relation reference ToTable CPlusDefNamespace$::$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Buff*&gt;::iterator end$Name$ = arr$Name$.end();
					while( iter$Name$ != end$Name$ ) {
						buff$Name$ = *iter$Name$;
						iter$Name$ ++;$reference ClearSubDep implRamDeleteTableClearThisOne$
					}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearDepWalkSaveEditBuff">
						else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
							editBuff = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$pop 1 EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( buff ) ) );
						}</GenRule>

<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearPassSubDep2Arg">,
							buff$popto ClearSubDep1 Name$-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="ClearSubDep3" Name="implRamDeleteTableClearThisOne">
					{
						$popto ClearSubDep2 reference Relation reference ToTable CPlusDefNamespace$::$popto ClearSubDep2 reference Relation reference ToTable EffSchemaName$$popto ClearSubDep2 reference Relation reference ToTable Name$Buff* editBuff = NULL;
						$popto ClearSubDep2 reference Relation reference ToTable CPlusDefNamespace$::$popto ClearSubDep2 reference Relation reference ToTable EffSchemaName$$popto ClearSubDep2 reference Relation reference ToTable Name$Buff* buff = schema-&gt;getTable$popto ClearSubDep2 reference Relation reference ToTable TableName$()-&gt;readDerivedBy$popto ClearSubDep2 reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$popto ClearSubDep2 reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearPassSubDep2Arg )$ );$reference Relation iterate Columns( each implRamDeleteTableClearRelationFromAttr empty empty )$
						classCode = buff-&gt;getClassCode();
						if( classCode == $popto ClearSubDep2 reference Relation reference ToTable CPlusDefNamespace$::$popto ClearSubDep2 reference Relation reference ToTable DefSchemaName$$popto ClearSubDep2 reference Relation reference ToTable TableName$Buff::CLASS_CODE ) {
							editBuff = dynamic_cast&lt;$popto ClearSubDep2 reference Relation reference ToTable CPlusDefNamespace$::$popto ClearSubDep2 reference Relation reference ToTable EffSchemaName$$popto ClearSubDep2 reference Relation reference ToTable Name$Buff*&gt;( schema-&gt;getTable$popto ClearSubDep2 reference Relation reference ToTable TableName$()-&gt;update$popto ClearSubDep2 reference Relation reference ToTable TableName$( Authorization, buff ) );
						}$popto ClearSubDep2 reference Relation reference ToTable iterate TableDeepSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$
						else {
							if( buff != NULL ) {
								delete buff;
								buff = NULL;
							}
							std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
							throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
								S_ProcName,
								S_Msg );
						}
						if( editBuff != NULL ) {
							delete editBuff;
							editBuff = NULL;
						}
					}
				</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableClearRelationToAttr">
						buff-&gt;set$reference ToCol OptionalOrRequired$$reference ToCol Name$Null();</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableClearRelationFromAttr"
						>$switch RelationFromAttrIsNullable yes implRamDeleteTableReallyClearRelationFromAttr default empty$</GenRule>

	<GenRule GenDef="RelationCol" Name="RelationFromAttrIsNullable"
		>$reference FromCol IsNullable$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableReallyClearRelationFromAttr">
						buff-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdatePrev">
		$reference Chain reference PrevRel reference ToTable CPlusDefNamespace$::$reference Chain reference PrevRel reference ToTable EffSchemaName$$reference Chain reference PrevRel reference ToTable TableName$Buff* prev = NULL;
		$reference Chain reference PrevRel reference ToTable CPlusDefNamespace$::$reference Chain reference PrevRel reference ToTable EffSchemaName$$reference Chain reference PrevRel reference ToTable TableName$Buff* editPrev = NULL;
		if( $reference Chain reference PrevRel iterate Columns( first implRamDeleteTableUpdatePrevCheckNotNull each implRamDeleteTableUpdatePrevCheckAndNotNull )$ ) {
			prev = schema-&gt;getTable$reference Chain reference PrevRel reference ToTable TableName$()-&gt;readDerivedBy$reference Chain reference PrevRel reference ToIndex Suffix$( Authorization$reference Chain reference PrevRel iterate Columns( each implRamTableUpdatePrevPassCommaVar )$ );
			if( prev == NULL ) {
				throw cflib::CFLibNullArgumentException( CLASS_NAME,
					S_ProcName,
					0,
					S_Prev );
			}$reference Chain reference NextRel iterate Columns( each implRamDeleteTableUpdatePrevSetPrevNext )$
			classCode = prev-&gt;getClassCode();
			if( classCode == $CPlusDefNamespace$::$reference Chain reference PrevRel reference ToTable DefSchemaName$$reference Chain reference PrevRel reference ToTable TableName$Buff::CLASS_CODE ) {
				editPrev = schema-&gt;getTable$reference Chain reference PrevRel reference ToTable TableName$()-&gt;update$reference Chain reference PrevRel reference ToTable TableName$( Authorization, prev );
			}$reference Chain reference PrevRel reference ToTable iterate TableDeepSubClasses( each implRamDeleteTableUpdatePrevWalkUpdateBuff empty empty )$
			else {
				if( editPrev != NULL ) {
					delete editPrev;
					editPrev = NULL;
				}
				if( prev != NULL ) {
					delete prev;
					prev = NULL;
				}
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg );
			}
			if( editPrev != NULL ) {
				delete editPrev;
				editPrev = NULL;
			}
			prev = NULL;
		}
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdatePrevSetPrevNext">
			if( next$reference ToCol Name$ == NULL ) {
				prev-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();
			}
			else {
				prev-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( *next$reference ToCol Name$ );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdatePrevWalkUpdateBuff">
			else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				editPrev = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( prev ) ) );
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdatePrevCheckNotNull"
		>( prev$reference ToCol Name$ != NULL )</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdatePrevCheckAndNotNull">
			&amp;&amp; $implRamDeleteTableUpdatePrevCheckNotNull$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamTableUpdatePrevPassCommaVar">,
				*prev$reference ToCol Name$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdateNext">
		$reference Chain reference NextRel reference ToTable CPlusDefNamespace$::$reference Chain reference NextRel reference ToTable EffSchemaName$$reference Chain reference NextRel reference ToTable TableName$Buff* next = NULL;
		$reference Chain reference NextRel reference ToTable CPlusDefNamespace$::$reference Chain reference NextRel reference ToTable EffSchemaName$$reference Chain reference NextRel reference ToTable TableName$Buff* editNext = NULL;
		if( $reference Chain reference NextRel iterate Columns( first implRamDeleteTableUpdateNextCheckNotNull each implRamDeleteTableUpdateNextCheckAndNotNull )$ ) {
			next = schema-&gt;getTable$reference Chain reference NextRel reference ToTable TableName$()-&gt;readDerivedBy$reference Chain reference NextRel reference ToIndex Suffix$( Authorization$reference Chain reference NextRel iterate Columns( each implRamTableUpdateNextPassCommaVar )$ );
			if( next == NULL ) {
				throw cflib::CFLibNullArgumentException( CLASS_NAME,
					S_ProcName,
					0,
					"next" );
			}
			classCode = next-&gt;getClassCode();$reference Chain reference PrevRel iterate Columns( each implRamDeleteTableUpdateNextSetNextPrev )$
			if( classCode == $CPlusDefNamespace$::$reference Chain reference NextRel reference ToTable DefSchemaName$$reference Chain reference NextRel reference ToTable TableName$Buff::CLASS_CODE ) {
				editNext = schema-&gt;getTable$reference Chain reference NextRel reference ToTable TableName$()-&gt;update$reference Chain reference NextRel reference ToTable TableName$( Authorization, next );
			}$reference Chain reference NextRel reference ToTable iterate TableDeepSubClasses( each implRamDeleteTableUpdateNextWalkUpdateBuff empty empty )$
			else {
				if( editNext != NULL ) {
					delete editNext;
					editNext = NULL;
				}
				if( next != NULL ) {
					delete next;
					next = NULL;
				}
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( classCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg );
			}
			if( editNext != NULL ) {
				delete editNext;
				editNext = NULL;
			}
			next = NULL;
		}
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdateNextSetNextPrev">
			if( prev$reference ToCol Name$ == NULL ) {
				next-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$Null();
			}
			else {
				next-&gt;set$reference FromCol OptionalOrRequired$$reference FromCol Name$$switch IsFromColNullable yes implRamValue default empty$( *prev$reference ToCol Name$ );
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdateNextWalkUpdateBuff">
			else if( classCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				editNext = dynamic_cast&lt;$pop 1 CPlusDefNamespace$::$EffSchemaName$$pop 1 TableName$Buff*&gt;( schema-&gt;getTable$TableName$()-&gt;update$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$EffSchemaName$$TableName$Buff*&gt;( next ) ) );
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdateNextCheckNotNull"
		>( next$reference ToCol Name$ != NULL )</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdateNextCheckAndNotNull">
			&amp;&amp; $implRamDeleteTableUpdateNextCheckNotNull$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamTableUpdateNextPassCommaVar">,
				*next$reference ToCol Name$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableChainSelectChainLinks">
$reference Chain reference PrevRel iterate Columns( each implRamDeleteTableChainSelectPrevChainLink )$$reference Chain reference NextRel iterate Columns( each implRamDeleteTableChainSelectNextChainLink )$
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableChainSelectPrevChainLink">
		$reference FromCol declConstAtomType$ prev$reference ToCol Name$ = existing-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$reference FromCol switch IsNullable yes implRamReference default empty$();</GenRule>

	<GenRule GenDef="Object" Name="implRamReference">Reference</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableChainSelectNextChainLink">
		$reference FromCol declConstAtomType$ next$reference ToCol Name$ = existing-&gt;get$reference FromCol OptionalOrRequired$$reference FromCol Name$$reference FromCol switch IsNullable yes implRamReference default empty$();</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableInvokeSuper">
		schema-&gt;getTable$reference SuperClassRelation reference ToTable TableName$()-&gt;delete$reference SuperClassRelation reference ToTable TableName$( Authorization,
			Buff );</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableCommaPassBuffArg">,
			Buff-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableByIndexCheckForNotNullColumn"
		>$switch IsNullable yes implRamDeleteTableByIndexCheckNullableColumn default implRamDeleteTableByIndexCheckRequiredColumn$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableByIndexCheckNullableColumn">
		if( argKey-&gt;is$OptionalOrRequired$$Name$Null() ) {
			anyNotNull = true;
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableByIndexCheckRequiredColumn">
		anyNotNull = true;</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableByIndex">
	void $poptop Table SchemaName$Ram$poptop Table TableName$Table::delete$poptop Table TableName$By$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each implNextIdGenDeclAttr )$ )
	{
		$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key key;$iterate Columns( each implRamDeleteApplyArgToKey )$
		delete$poptop Table TableName$By$Suffix$( Authorization, &amp;key );
	}

	void $poptop Table SchemaName$Ram$poptop Table TableName$Table::delete$poptop Table TableName$By$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key* argKey )
	{$switch implDeleteTableBySuffixNeedProcName yes implDeleteTableBySuffixImplProcName default empty$
		$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* cur = NULL;
		$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* rereadCur = NULL;
		bool anyNotNull = false;$iterate Columns( each implRamDeleteTableByIndexCheckForNotNullColumn )$
		if( ! anyNotNull ) {
			return;
		}
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt; matchSet;
		std::map&lt;$CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
			$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator iter = dictByPKey-&gt;begin();
		std::map&lt;$CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
			$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator end = dictByPKey-&gt;end();
		while( iter != end ) {
			cur = iter-&gt;second;
			iter ++;
			if( *dynamic_cast&lt;$CPlusDefNamespace$::$reference Table DefSchemaName$$reference Table TableName$Buff*&gt;( cur ) == *argKey ) {
				matchSet.push_back( dynamic_cast&lt;$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( cur-&gt;clone() ) );
			}
		}
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator iterMatch = matchSet.begin();
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator matchEnd = matchSet.end();
		while( iterMatch != matchEnd ) {
			cur = *iterMatch;
			iterMatch ++;
			cur = schema-&gt;getTable$poptop Table TableName$()-&gt;readDerivedBy$poptop Table reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableBySuffixPassCurPKeyArg )$ );
			rereadCur = cur;$poptop Table switch HasSubClasses yes implDeleteTableBySuffixClassWalker default implDeleteTableBySuffixDirect$
			delete rereadCur;
			rereadCur = NULL;
		}
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableBySuffixPassCurPKeyArg">,
				cur-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Index" Name="implDeleteTableBySuffixNeedProcName"
		>$poptop Table HasSubClasses$</GenRule>

	<GenRule GenDef="Index" Name="implDeleteTableBySuffixImplProcName">
		static const std::string S_ProcName( "delete$poptop Table TableName$By$Suffix$" );</GenRule>

	<GenRule GenDef="Table" Name="implDeleteTableBySuffixDirect">
			delete$TableName$( Authorization, cur );</GenRule>

	<GenRule GenDef="Table" Name="implDeleteTableBySuffixClassWalker">
			classcode_t subClassCode = cur-&gt;getClassCode();
			if( subClassCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				schema-&gt;getTable$TableName$()-&gt;delete$TableName$( Authorization, cur );
			}$iterate ReverseRelations( each implDeleteTableBySuffixClassWalker empty empty )$
			else {
				std::string S_Msg( "Unrecognized ClassCode \\"" + cflib::CFLib::formatClassCode( subClassCode ) + "\\"" );
				throw cflib::CFLibUnsupportedClassException( CLASS_NAME,
					S_ProcName,
					S_Msg );
			}</GenRule>

	<GenRule GenDef="Relation" Name="implDeleteTableBySuffixClassWalker"
		>$switch RelationTypeTag
			Superclass implDeleteTableBySuffixWalkClass
			default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implDeleteTableBySuffixWalkClass"
		>$reference FromTable implDeleteTableBySuffixWalkClass$</GenRule>

	<GenRule GenDef="Table" Name="implDeleteTableBySuffixWalkClass">
			else if( subClassCode == $CPlusDefNamespace$::$DefSchemaName$$TableName$Buff::CLASS_CODE ) {
				schema-&gt;getTable$TableName$()-&gt;delete$TableName$( Authorization, dynamic_cast&lt;$CPlusDefNamespace$::$DefSchemaName$$TableName$Buff*&gt;( cur ) );
			}$iterate ReverseRelations( each implDeleteTableBySuffixClassWalker empty empty )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteApplyArgToKey"
		>$switch IsNullable yes implRamDeleteApplyOptArgToKey default implRamDeleteApplyReqArgToKey$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteApplyOptArgToKey">
		if( arg$Name$ == NULL ) {
			key.set$OptionalOrRequired$$Name$Null();
		}
		else {
			key.set$OptionalOrRequired$$Name$Value( $switch BaseModelAtomClass UuidGen empty UuidDef empty default emitAsterisk$arg$Name$ );
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteApplyReqArgToKey">
		key.set$OptionalOrRequired$$Name$( arg$Name$ );</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteCommaPassArgColumn"
		>$switch IsNullable yes implRamDeleteCommaPassOptArgColumn default implRamDeleteCommaPassReqArgColumn$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteCommaPassOptArgColumn">,
			argKey-&gt;get$OptionalOrRequired$$Name$Reference()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteCommaPassReqArgColumn">,
			argKey-&gt;get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableByPrimaryIndex">
	void $poptop Table SchemaName$Ram$poptop Table TableName$Table::delete$poptop Table TableName$By$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization$iterate Columns( each implNextIdGenDeclAttr )$ )
	{
		$CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey key;$iterate Columns( each implRamDeleteApplyArgToKey )$
		delete$poptop Table TableName$By$Suffix$( Authorization, &amp;key );
	}

	void $poptop Table SchemaName$Ram$poptop Table TableName$Table::delete$poptop Table TableName$By$Suffix$( const $CPlusSecNamespace$::$SecSchemaName$Authorization* Authorization,
		const $CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey* argKey )
	{$switch implDeleteTableBySuffixNeedProcName yes implDeleteTableBySuffixImplProcName default empty$
		bool anyNotNull = false;$iterate Columns( each implRamDeleteTableByIndexCheckForNotNullColumn )$
		if( ! anyNotNull ) {
			return;
		}
		$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* cur = NULL;
		$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff* rereadCur = NULL;
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt; matchSet;
		std::map&lt;$CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
			$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator iter = dictByPKey-&gt;begin();
		std::map&lt;$CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
			$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator end = dictByPKey-&gt;end();
		while( iter != end ) {
			cur = iter-&gt;second;
			iter ++;
			if( *dynamic_cast&lt;$CPlusDefNamespace$::$reference Table DefSchemaName$$reference Table TableName$Buff*&gt;( cur ) == *argKey ) {
				matchSet.push_back( dynamic_cast&lt;$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;( cur-&gt;clone() ) );
			}
		}
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator iterMatch = matchSet.begin();
		std::TCFLibOwningVector&lt;$CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;::iterator matchEnd = matchSet.end();
		while( iterMatch != matchEnd ) {
			cur = *iterMatch;
			iterMatch ++;
			cur = schema-&gt;getTable$poptop Table TableName$()-&gt;readDerivedBy$poptop Table reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableBySuffixPassCurPKeyArg )$ );
			rereadCur = cur;$poptop Table switch HasSubClasses yes implDeleteTableBySuffixClassWalker default implDeleteTableBySuffixDirect$
			if( rereadCur != NULL ) {
				delete rereadCur;
				rereadCur = NULL;
			}
		}
	}
</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableIntegrityCheck"
		>$switch RelationTypeTag
			Superclass implRamDeleteTableCheckSuperClassReference
			Lookup implRamDeleteTableCheckReference
			Master empty
			Container empty
			Owner empty
			default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckReference"
		>$switch IsRequired yes implRamDeleteTableCheckReqRef default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckSuperClassReference">
		{
			$reference FromTable CPlusDefNamespace$::$reference FromTable DefSchemaName$$reference FromTable Name$Buff* ref$implRamToIndexSuffix$ = dynamic_cast&lt;$reference FromTable CPlusDefNamespace$::$reference FromTable DefSchemaName$$reference FromTable Name$Buff*&gt;( schema-&gt;getTable$reference FromTable Name$()-&gt;readDerivedBy$implRamToIndexSuffix$( Authorization$iterate Columns( each implRamDeleteTableCheckRefCommaPassArg )$ ) );
			if( ref$implRamToIndexSuffix$ != NULL ) {
				delete ref$implRamToIndexSuffix$;
				ref$implRamToIndexSuffix$ = NULL;
				std::string Msg( "Dependents detected for $RelationTypeTag$ relationship $Name$ from table $reference FromTable Name$ for primary key " + pkey.toString() );
				throw cflib::CFLibDependentsDetectedException( CLASS_NAME,
					S_ProcName,
					Msg );
			}
		}
</GenRule>

	<GenRule GenDef="Relation" Name="IsFromIndexUnique"
		>$reference FromIndex IsUnique$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckReqRef"
		>$switch IsFromIndexUnique yes implRamDeleteTableCheckUniqueRef default implRamDeleteTableCheckDupRef$</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckUniqueRef">
		$reference FromTable CPlusDefNamespace$::$reference FromTable DefSchemaName$$reference FromTable Name$Buff* ref$impRamFromIndexSuffix$ = dynamic_cast&lt;$reference FromTable CPlusDefNamespace$::$reference FromTable DefSchemaName$$reference FromTable Name$Buff*&gt;( schema-&gt;getTable$reference FromTable Name$()-&gt;readDerivedBy$implRamFromIndexSuffix$( Authorization$iterate Columns( each implRamDeleteTableCheckRefCommaPassArg )$ ) );
		if( ref$implRamFromIndexSuffix$ != NULL ) {
			delete ref$implRamFromIndexSuffix$;
			ref$implRamFromIndexSuffix$ = NULL;
			std::string Msg( "Dependents detected for $RelationTypeTag$ relationship $Name$ from table $reference FromTable Name$ for primary key " + pkey.toString() );
			throw cflib::CFLibDependentsDetectedException( CLASS_NAME,
				S_ProcName,
				Msg );
		}
</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckDupRef">
		std::TCFLibOwningVector&lt;$reference FromTable CPlusDefNamespace$::$reference FromTable DefSchemaName$$reference FromTable TableName$Buff*&gt; derivedBy$implRamFromIndexSuffix$ = schema-&gt;getTable$reference FromTable Name$()-&gt;readDerivedBy$implRamFromIndexSuffix$( Authorization$iterate Columns( each implRamDeleteTableCheckRefCommaPassArg )$ );
		if( derivedBy$implRamFromIndexSuffix$.size() &gt; 0 ) {
			std::string Msg( "Dependents detected for $RelationTypeTag$ relationship $Name$ from table $reference FromTable Name$ for primary key " + pkey.toString() );
			throw cflib::CFLibDependentsDetectedException( CLASS_NAME,
				S_ProcName,
				Msg );
		}
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableCheckRefCommaPassArg">,
						$implRamDeleteTableCheckRefPassArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableCheckRefPassArg"
		>$switch FromColIsNullable yes implRamDeleteTableCheckRefPassOptArg default implRamDeleteTableCheckRefPassReqArg$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableCheckRefPassOptArg"
		>existing-&gt;get$reference ToCol implColumnAttrOptionality$$reference ToCol Name$Reference()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableCheckRefPassReqArg"
		>existing-&gt;get$reference ToCol implColumnAttrOptionality$$reference ToCol Name$()</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamDeleteTableRemoveIndexEntry"
		>$switch IsPrimaryIndex yes empty default implRamDeleteTableRemoveIndexEntry$</GenRule>
	<GenRule GenDef="Index" Name="implRamDeleteTableRemoveIndexEntry"
		>$switch IsUnique yes implRamDeleteTableRemoveUniqueEntry default implRamDeleteTableRemoveDupEntry$</GenRule>
	<GenRule GenDef="Index" Name="implRamDeleteTableRemoveUniqueEntry">
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( key$Suffix$ );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			dictBy$Suffix$-&gt;erase( searchDictBy$Suffix$ );
		}
</GenRule>
	<GenRule GenDef="Index" Name="implRamDeleteTableRemoveDupEntry">
		auto searchDictBy$Suffix$ = dictBy$Suffix$-&gt;find( key$Suffix$ );
		if( searchDictBy$Suffix$ != dictBy$Suffix$-&gt;end() ) {
			std::map&lt;$poptop Table reference BaseClass CPlusDefNamespace$::$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey,
				 $poptop Table CPlusDefNamespace$::$poptop Table DefSchemaName$$poptop Table TableName$Buff*&gt;* subdict$Suffix$ = searchDictBy$Suffix$-&gt;second;
			auto searchSubDict = subdict$Suffix$-&gt;find( pkey );
			if( searchSubDict != subdict$Suffix$-&gt;end() ) {
				subdict$Suffix$-&gt;erase( searchSubDict );
			}
			subdict$Suffix$ = NULL;
		}
</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamDeleteTableInitIndexKey"
		>$switch IsPrimaryIndex yes empty default implRamDeleteTableInitIndexKey$</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableInitIndexKey">
		$CPlusDefNamespace$::$DefSchemaName$$TableName$By$Suffix$Key key$Suffix$;$iterate Columns( each implRamDeleteTableInitExistingKeyAttr )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableInitExistingKeyAttr"
		>$switch IsNullable yes implRamDeleteTableInitExistingOptKeyAttr default implRamDeleteTableInitExistingReqKeyAttr$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableInitExistingOptKeyAttr">
		if( existing-&gt;is$implColumnAttrOptionality$$Name$Null() ) {
			key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$Null();
		}
		else {
			key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$Value( existing-&gt;get$implColumnAttrOptionality$$Name$Value() );
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableInitExistingReqKeyAttr">
		key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( existing-&gt;get$implColumnAttrOptionality$$Name$() );</GenRule>

</RuleSet>
